
= XtightlyCoupledIO
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.13.1
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that maximally reduces the duplications as those are hard to maintain.

There was no attempt at optimizing instruction decoding, (or packing them in less opcodes) 
other than sticking close to canonical risc-v encodings, yet.

The spec can be donated (FOSS org??), if it allows it to undergo more comparative studies and proceed to "standardization" 

[[chapter_title]]
== Introduction

The scope of XTightlyCoupledIO extension is to reduce code size, increase performance
in peripheral accessing code. It results in reduced latency in control loops etc.

This speec was created solely because we would have to wait for proprietary one otherwise.

And if we are talking about proprietary extensions, they are usually:

- Done wrong, mainly because specs are created on tight deadlines
- Not done at all (the most obvious and common approach)
- Those specs also almost never see an outside word and if they do, they are very badly 
documented or not documented at all (let's guess what custom instructions the ch32v003 or ch32v307 implements...)
- They also focus on gpio too much, leaving out the most frequently used or most critical peripherals. 

NOTE: In modern microcontroller codebases the gpio tends to be accessed less frequently
than other peripherals. And it's due to a simple reason - if the peripherals are 
present, they no longer have to be bit-banged by gpio as it was done in the past.

My observation of frequent peripheral patterns are:

- only single bit needs to be modified or branched on
- register is written with a heavy constant
- register written with zero
- in specific cases like STM32 BSRR or flag clearing, a single bit or inverted single bit constant is used
- the register content comes directly from/to memory
- otherwise the content is used in/comes from computations
- register content is immediately converted to float for computation

//?? write what is provided ??
// get rid of addr load ???
//registers are volatile so not much opt can be done??

=== prior art

==== avr8

Provides 64 IO registers each being accesible by `in` and `out` instructions, 32 o them 
being available for the single bit instructions.
All registers are available through IO address space and memory addres space.

Single bit instructions consists of:

- `sbi` and `cbi` for setting and clearing bits
- `sbis` and `sbic` that can sip one instruction if IO bit is set/cleared
- `sbrc` and `sbrs` that can sip one instruction if bit in general purpose register is set/cleared

There are also `gpior` registers that serve as a scratch registers for e.g. global variables/flags. 
Has to be used explicitly in source code.

.everything looks clean and nice but...

let's have a look on, how efficiently it's used:

atmega8::
- 3 reserved registers in bottom io space
- 8 non-bit registers in bottom io space 

atmega328p::
The most used chip in arduino, as well as the most cloned one. 
+
- 15 reserved registers in bottom io space
- 10 reserved registers in upper io space
- many registers available only as memory mapped

xmega::
- half of the bottom IO space is dedicated for `GPIO` (aka `gpior`) registers
- the other half is taken by VPORTs that can map to any gpio port configured
- area between 0x1f and 0x30 is not populated at all +
- 0x30 to 0x3f is populated by "CPU"
+
VPORTs have to be configured and used explicitly in source code.

AVR-DA::
One of the most recent avr8 family after Microchip.
+
similarly to xmega, there is only 7 GPIO virtual ports and 4 `GPR` (aka `gpior`) registers +
the upper part is populated only by the "CPU"

//???? There are 7 gpio ports and 7 virtual ones, are those actually mapped like 
//???? in the old avr or xmega (explicitly in source code)

==== ti PRU (in beaglebone sbcs)

r30 gpio output +
r31 gpio input

special instructions

==== ti c2/f2

<<spracw5a>> claims 2 cycle for ADC reg to float, Fig 4-3 claims 3x cycle speedup over cortex m4 (stm32g4)

==== ???

=== alternative approaches

==== map tu upper GPR

Available on RVE only. Limited to 16 GPR mapped registers.
Allows to recycle standard risc-v instructions operating on GPRs. 

==== use custom `csr` registers

csrr* instrtuctions implement an atomic swap and bitmask set/clear operations.

However `csr` registers are generally used to modify core architectural behaviour and thus perform slower than expected.

NOTE: for this reason RISC-V V spec forbids writes to `vtype` and `vl` with anything but `vsetvl` instructions

NOTE: xpulp extension is also planning on disallowing writes to hwloop registers with general csr instructions

==== bitbanding

Implemented by cortex-m3 and cortex-m4

Not available on cortex-m0 and cortex-m7, optional on cortex-m3/m4. +
Still requires loading of base address for bitbanded bit. 
Must be used explicitly in source code

==== special purpose write only registers

Special kind of write only registers e.g BSRR/IFCR found in STM32 and clones. +
Still require loading of peripheral base address. Requires also generating 
preformatted (shifted) constants even if only single bit is written.

NOTE: BSRR is still usefull for `tio.mv` acces as it can work on non-continous bitfields 
or content from pre generated lookup tables 

=== omitted instructions

==== load to IO/store from IO register

Useful to directly store or load IO content to/from memory without processing.
It is also non deterministic and can trap due to e.g. alignment or pmp restrictions, violating atomicity guarantee.

NOTE: still available in first alternative approach

==== IO with multiply/multiply-accumulate

non deterministic, sometimes multi cycle

[[chapter_title]]
== programmers model

The XTightlyCoupledIO extension adds 4 banks of 32 XLEN sized IO registers each.
The IO registers are reffered from `rs1` and/or `rd` field. Named `ios1` and `iod`.

If a given bank is not populated, corresponding instructions are reserved.

Non-idempotent part of the IO targetting instructions must execute atomically.
Therefore those instructions cannot be interrupted with visible side-effects.

NOTE: number of banks and availability in certain instructions was decided
totally arbitrarily, will be refined later

NOTE: it is recommended to not keep registers mapped lienarly one after the other but 
split into appropriate banks. e.g. read/write data register doesn't need to live in a bit operable banks.

=== side effects

For easier mapping to high level languages, any access to IO registers causes
side effects as if the entire XLEN sized word was accessed.

A partial modification triggers side effects as if the entire XLEN sized word
was read, modified and written back.

[source, C]
```
GPIOA->OUT |= (1<<13);
//is equivalent to
tio.sbseti io123, io123, 13
```

==== TODO: grouping of bits from multiple different registers

//bit views ???

For more efficient use of IO register space available by certain instructions.

Not reflecting actual memory mapped registers.

==== TODO: multi core atomicity etc.

Core vs DMA is a likely scenario. +
In C the above RMW operation is non atomic. The tio isntructions can do atomic RMW what 
could lead to abuse of observed behaviour (bugs when porting from tio to non-tio mcu)

=== automatic mapping of memory mapped registers to tightly coupled registers

For efficient use (aka having it used at all) of the `tio` instructions, the compilers
need to automatically translate accesses to memory mapped registers into IO address space.

In case of avr8, the compiler received information about target mcu by the "-mcpu=" flag, for
automatic mapping of memory mapped peripherals into IO address space.
As the Atmel defacto controlled avr architecture, they had all of the possible IO mappings upstreamed.
Any chinese clone was cloning the IO address space layout of existing device exactly.

In case of risc-v we are about to end up with thousands outdated builds of custom toolchains. 
As is already happening with interrupt controllers (e.g. WCH hw stacking)

Therefore we need an unified file format describing peripheral to IO mapping, that will be provided by vendors. 
It will be passed to compiler command line similarly to source code or linker scripts.

NOTE: Those mapping files can be also self made in case of "typical chinese vendors"

NOTE: Those files could be used to provide named aliases in debuggers/decompilers

==== TODO: define the iomapping file format

==== TODO: named aliases for use in assembly

=== assembly syntax

All IO accessing instructions are prefixed with `tio.` prefix. +
Bank number is part of the instruction name, except supplementary instructions. +
The suffix denominates wether `rd` or `rs1` field targets io registers +
Takes the form of `tio.instr{n}.{rd}{rs1}` where {n} is the bank number
and {rd} and {rs1} are substituted with one of the following letters .

- x - integer reg
- s - floating point reg
- y - io reg

Register specifiers use the same letter.

```
tio.sbseti3.yy y11, y11, 13 // set bit 13 in io 11 register in bank 3
tio.sbseti2.yx y22, zero, 17 // write (1<<17) to io 22 register in bank 2
```

NOTE: letter y was picked totally arbitrarily as it's single letter and doesn't have conflicts

==== pseudoinstructions

`tio` instructions referred to without the bank number and suffix.

Pseudoinstructions use the `io` name prefix as the register specifier with
linearized addressing. The `.yy` form cannot cross the banks.

```
tio.sbseti io107, io107, 13 // set bit 13 in io 11 register in bank 3
tio.sbseti io86, zero, 17 // write (1<<17) to io 22 register in bank 2
```

===== Canonical io move instruction

The following instructions are designated as a canonical IO move instructions:

```
tio.add{n}.yx iod, rs1, zero 
tio.add{n}.xy rd, ios1, zero
tio.add{n}.yy iod, ios1, zero // doesn't cross banks
```

Available under `tio.mv` name with suffixed or linearized version.

NOTE: The canonical move in base risc-v is an `addi`, but because of 
limited encoding, `tio.addi` cannot be provided with all necessary forms.
Therefore alternative instruction was picked.

NOTE: `tio.add` was picked because an addition is one of the most common 
operations and the add ALU tend's to be most available one. e.g. cortex-m7
doesn't provide bitwise and/or/xor in its early ALU

[[chapter_title]]
== XTightlyCoupledIO subextensions

The name `XTightlyCoupledIO` can be used as a catch all of following extensions.
	
NOTE: only the low 32bits of target register is accesible by branch instructions on rv64
	
=== XTightlyCoupledIOsupp

Supplementary instructions useful for alternative upper GPR approach.
Potentially usefull in non IO code.

==== tio.bsbseti.x

Synopsis::
Branch if single bit in register is set (immediate)

Mnemonic::
```
tio.bsbset.x rs1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

NOTE: instruction proposed as Zce 32bit candidate

==== tio.bsbclri.x

Synopsis::
Branch if single bit in register is cleared (immediate)

Mnemonic::
```
tio.bsbclr.x rs1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

NOTE: instruction proposed as Zce 32bit candidate

==== tio.bfinserti.xx

Synopsis::
Destructive bitfield insert into register (immediate)

Mnemonic::
```
tio.bfinserti.xx rd, rs1, shamt, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: due to encoding constraints only destructive form is provided

NOTE: instruction was proposed for P extension as there are many more rd destructive ones 

=== XTightlyCoupledIOa

general IO alu, instructions

==== tio.addi.yx

Synopsis::
Add immediate and write to io register

Mnemonic::
```
tio.addi{bsel}.yx iod, rs1, imm
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 2, name: 0b00 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'rs1' },
 { bits: 12, name: 'imm[11:0]' },
]}
....

NOTE: `lui` + `tio.addi` pair can be used to write any 32bit constant into IO register.

=== XTightlyCoupledIOsb

single bit IO access instructions

=== XTightlyCoupledIOsbbr

branch on single IO bit instriuctions

==== tio.bsbseti.y

Synopsis::
Branch if single bit in IO register is set (immediate)

Mnemonic::
```
tio.bsbseti{bsel}.y ios1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 2, name: 0b10 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

==== tio.bsbclri.y

Synopsis::
Branch if single bit in IO register is cleared (immediate)

Mnemonic::
```
tio.bsbclri{bsel}.y ios1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 2, name: 0b11 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

=== XTightlyCoupledIObf

IO destructive bitfield insert

==== tio.bfinserti.yx

Synopsis::
Destructive bitfield insert into IO register (immediate)

Mnemonic::
```
tio.bfinserti{bsel}.yx iod, rs1, shamt, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 2, name: 0b01 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: due to encoding constraints only destructive form is provided

NOTE: rv64 encoding could tradeoff the extra len/offset range similarly to branches

=== XTightlyCoupledIOcm

implemented similarly to Zcm* extenaions, incompatible with Zcd

=== XTightlyCoupledIOfcvt

implemented similarly to F or Zfinx instructions

NOTE: readings are often immediately converted to float for processing in control loop algorithms

==== tio.fcvt.s.w.sy

Synopsis::
Read IO register and convert to float

Mnemonic::
```
tio.fcvt{bsel}.s.w.sy rd, ios1, rm
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-3'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 'rm' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 0b00000 },
 { bits: 2, name: 'fmt', attr: ['S'] },
 { bits: 3, name: 0b000 },
 { bits: 2, name: 'bsel[1:0]' },
]}
....

Prerequisites::
F or Zfinx

==== tio.fcvt.s.wu.sy

Synopsis::
Read IO register and convert to float

Mnemonic::
```
tio.fcvt{bsel}.s.wu.sy rd, ios1, rm
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-3'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 'rm' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 0b00001 },
 { bits: 2, name: 'fmt', attr: ['S'] },
 { bits: 3, name: 0b000 },
 { bits: 2, name: 'bsel[1:0]' },
]}
....

Prerequisites::
F or Zfinx

==== TODO: double precision and rv64
//need to reduce duplication

[appendix]
= code samples


[appendix]
= test


Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x0, attr: ['yyy'] },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 7, name: 0x01, attr: ['aaa'] },
]}
....

costom 0 - 0b00 010 11 - 0x0b

custom 1 - 0b01 010 11 - 0x2b

custom 2 - 0b10 110 11 - 0x5b

custom 3 - 0b11 110 11 - 0x7b


[wavedrom, , svg]
....
{reg:[
    { bits:  2, name: 0x0, attr: ['C0'] },
    { bits:  11, name: '', attr: ['FLD'] },
    { bits:  3, name: 0b001, attr: ['FUNCT3'] },
],config:{bits:16}}
....

FSD - 101 00

FLDSP - 001 10

FSDSP allocated by Zce

[bibliography]
= Bibliography

* [[[spracw5a, 1]]] https://www.ti.com/lit/an/spracw5a/spracw5a.pdf