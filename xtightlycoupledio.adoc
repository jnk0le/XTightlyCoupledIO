
= XtightlyCoupledIO
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.3.2
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/POC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. Assembly syntax change is a minor increment.
Version 1.0.0 is the first publicly released. Changes in prior versions are not tracked in revision history.

Document is written in a way that maximally reduces the duplications as those are hard to maintain.

There was no attempt at optimizing instruction decoding, (or packing them in less opcodes) 
other than sticking close to canonical risc-v encodings, yet.

The spec can be donated (FOSS org??), if it allows it to undergo more comparative studies and proceed to "standardization" 

[[chapter_title]]
== Introduction

reduce code size and increase performance

reduce the latency in control loops etc.



observation is

comes from computation

is used for comutation


=== prior art

==== avr8

==== ti PRU (in beaglebone sbcs)

r30 gpio output
r31 gpio input

==== ti c2/f2

claims 2 cycle for ADC reg to float, Fig 4-3 claims 3x cycle speedup over cortex m4 (stm32g4)
https://www.ti.com/lit/an/spracw5a/spracw5a.pdf

==== ???

=== alternative approaches

==== map tu upper GPR

Available on RVE only. Limited to 16 GPR mapped registers.

==== use custom `csr` registers

However `csr` registers are generally used to modify core architectural behaviour and thus perform slower than expected.

==== bitbanding

Implemented by cortex-m3 and cortex-m4

Not available on cortex-m0 and cortex-m7, optional on cortex-m3/m4. +
Still requires loading of base address for bitbanded bit. 
Must be used explicitly in source code

==== special purpose write only registers

Special kind of write only registers e.g BSRR/IFCR found in STM32 and clones. +
Still require loading of peripheral base address. Requires also generating 
preformatted (shifted) constants even if only single bit is written.

NOTE: BSRR is still usefull for `tio.mv` acces as it can work on non-continous bitfields 
or content from pre generated lookup tables 

=== omitted instructions

==== load to IO/store from IO register

Useful to directly store or load IO content to/from memory without processing.
It is also non deterministic and can trap due to alignment or pmp restrictions, violating atomicity guarantee.

NOTE: still available in first alternative approach

==== IO with multiply/multiply-accumulate

non deterministic

[[chapter_title]]
== programmers model

The XTightlyCoupledIO extension adds 4 banks of 32 XLEN sized IO registers each.

If a given bank is not populated, corresponding instructions are reserved.

Non-idempotent part of the IO targetting instructions must execute atomically. 
Therefore those instructions cannot be interrupted with visible side-effects.

NOTE: number of banks and availability in certain instructions was decided
 totally arbitrarily, will be refined later

NOTE: it is recommended to not keep registers mapped lienarly one after the other but 
split into appropriate banks. e.g. read/write data register doesn't need to live in a bit operable banks.

=== side effects

For easier mapping to high level languages, any access to IO registers causes
side effects as if the entire XLEN sized word was accessed.

A partial modification triggers side effects as if the entire XLEN sized word
was read, modified and written back.

NOTE: easiest way to avoid implementation issues is to not have side
effects on reads or writes of the previously read value in config registers

[source, C]
```
GPIOA->OUT |= (1<<13);
//is equivalent to
tio.sbset io123, io123, 13
```

==== TODO: grouping of bits from multiple different registers

//bit views ???

For more efficient use of IO register space available by certain instructions.

Not reflecting actual memory mapped registers.

=== automatic mapping of memory mapped registers to tightly coupled registers

intrinsics are not gonna work well

//how to map regs by compiler (atmel approach -mmcu= vs special files)

=== assembly syntax

==== pseudoinstructions




[[chapter_title]]
== XTightlyCoupledIO subextensions

The name `XTightlyCoupledIO` can be used as a catch all of following extensions.
	
=== XTightlyCoupledIOsupp

Supplementary instructions useful for alternative upper GPR approach.
Potentially usefull in non IO code.
	
=== XTightlyCoupledIOa

general IO alu and IO move, instructions
	
=== XTightlyCoupledIOsb

single bit IO access instructions

=== XTightlyCoupledIOsbbr

branch on single IO bit instriuctions

=== XTightlyCoupledIObf

IO destructive bitfield insert

=== XTightlyCoupledIOcm

implemented similarly to Zcm* extenaions, incompatible with Zcd

=== XTightlyCoupledIOother

other instructions that should be actually somewhere else

=== TODO: read and convert to float




[appendix]
== code samples


[appendix]
== test


Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x0, attr: ['yyy'] },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 7, name: 0x01, attr: ['aaa'] },
]}
....


[wavedrom, , svg]
....
{reg:[
    { bits:  2, name: 0x0, attr: ['C0'] },
    { bits:  11, name: '', attr: ['FLD'] },
    { bits:  3, name: 0b001, attr: ['FUNCT3'] },
],config:{bits:16}}
....

FSD - 101 00

FLDSP - 001 10

//FSDSP allocated by Zce

