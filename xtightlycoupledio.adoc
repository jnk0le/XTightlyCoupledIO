
= XtightlyCoupledIO
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.6.2
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that maximally reduces the duplications as those are hard to maintain.

There was no attempt at optimizing instruction decoding, (or packing them in less opcodes) 
other than sticking close to canonical risc-v encodings, yet.

The spec can be donated (FOSS org??), if it allows it to undergo more comparative studies and proceed to "standardization" 

[[chapter_title]]
== Introduction

The scope of XTightlyCoupledIO extension is to reduce code size, increase performance
in peripheral accessing code. It results in reduced latency in control loops etc.

This speec was created solely because we would have to wait for proprietary one otherwise.

And if we are talking about proprietary extensions, they are usually:

- Done wrong, mainly because specs are created on tight deadlines
- Not doing it at all (the most obvious and common approach)
- Those specs also almost never see an outside word and if they do, they are very badly 
documented or not documented at all (let's guess what custom extensions the ch32v003 or ch32v307 implements...)
- They also focus on gpio too much, leaving out the most frequently used or most critical peripherals. 

NOTE: In modern microcontroller codebases the gpio tends to be accessed less frequently
than other peripherals. And it's due to a simple reason - if the peripherals are 
present, they no longer have to be bit-banged by gpio as it was done in the past.

My observation of frequent peripheral patterns are:

- only single bit needs to be modified or branched on
- register is written with a heavy constant
- register written with zero
- in specific cases like STM32 BSRR or flag clearing, a single bit or inverted single bit constant is used
- the register content comes directly from/to memory
- otherwise the content is used in/comes from computations
- register content is immediately converted to float for computation

//?? write what is provided ??

=== prior art

==== avr8

Provides 64 IO registers each being accesible by `in` and `out` instructions, 32 o them 
being available for the single bit instructions.
All registers are available through IO address space and memory addres space.

Single bit instructions consists of:

- `sbi` and `cbi` for setting and clearing bits
- `sbis` and `sbic` that can sip one instruction if IO bit is set/cleared
- `sbrc` and `sbrs` that can sip one instruction if bit in general purpose register is set/cleared

There are also `gpior` registers that serve as a scratch registers for e.g. global variables/flags. 
Has to be used explicitly in source code.

.everything looks clean and nice but...

let's have a look on, how efficiently it's used:

atmega8::

- 3 reserved registers in bottom io space +
- 8 non-bit registers in bottom io space 

atmega328p::

The most used chip in arduino, as well as the most cloned one. 

- 15 reserved registers in bottom io space +
- 10 reserved registers in upper io space +
- many registers available only as memory mapped

xmega::

- half of the bottom IO space is dedicated for `GPIO` (aka `gpior`) registers +
- the other half is taken by VPORTs that can map to any gpio port configured +
- area between 0x1f and 0x30 is not populated at all +
- 0x30 to 0x3f is populated by "CPU"

VPORTs have to be configured and used explicitly in source code.

AVR-DA::

One of the most recent avr8 family after Microchip.

similarly to xmega, there is only 7 GPIO virtual ports and 4 `GPR` (aka `gpior`) registers +
the upper part is populated only by the "CPU"

//???? There are 7 gpio ports and 7 virtual ones, are those actually mapped like 
//???? in the old avr or xmega (explicitly in source code)

==== ti PRU (in beaglebone sbcs)

r30 gpio output +
r31 gpio input

special instructions

==== ti c2/f2

<<spracw5a>> claims 2 cycle for ADC reg to float, Fig 4-3 claims 3x cycle speedup over cortex m4 (stm32g4)

==== ???

=== alternative approaches

==== map tu upper GPR

Available on RVE only. Limited to 16 GPR mapped registers.
Allows to recycle standard risc-v instructions operating on GPRs. 

==== use custom `csr` registers

csrr* instrtuctions implement an atomic swap and bitmask set/clear operations.

However `csr` registers are generally used to modify core architectural behaviour and thus perform slower than expected.

NOTE: for this reason RISC-V V spec forbids writes to `vtype` and `vl` with anything but `vsetvl` instructions

NOTE: xpulp extension is also planning on disallowing writes to hwloop registers with general csr instructions

==== bitbanding

Implemented by cortex-m3 and cortex-m4

Not available on cortex-m0 and cortex-m7, optional on cortex-m3/m4. +
Still requires loading of base address for bitbanded bit. 
Must be used explicitly in source code

==== special purpose write only registers

Special kind of write only registers e.g BSRR/IFCR found in STM32 and clones. +
Still require loading of peripheral base address. Requires also generating 
preformatted (shifted) constants even if only single bit is written.

NOTE: BSRR is still usefull for `tio.mv` acces as it can work on non-continous bitfields 
or content from pre generated lookup tables 

=== omitted instructions

==== load to IO/store from IO register

Useful to directly store or load IO content to/from memory without processing.
It is also non deterministic and can trap due to e.g. alignment or pmp restrictions, violating atomicity guarantee.

NOTE: still available in first alternative approach

==== IO with multiply/multiply-accumulate

non deterministic, sometimes multi cycle

[[chapter_title]]
== programmers model

The XTightlyCoupledIO extension adds 4 banks of 32 XLEN sized IO registers each.
The IO registers are reffered from `rs1` and/or `rd` field.

If a given bank is not populated, corresponding instructions are reserved.

Non-idempotent part of the IO targetting instructions must execute atomically.
Therefore those instructions cannot be interrupted with visible side-effects.

NOTE: number of banks and availability in certain instructions was decided
totally arbitrarily, will be refined later

NOTE: it is recommended to not keep registers mapped lienarly one after the other but 
split into appropriate banks. e.g. read/write data register doesn't need to live in a bit operable banks.

=== side effects

For easier mapping to high level languages, any access to IO registers causes
side effects as if the entire XLEN sized word was accessed.

A partial modification triggers side effects as if the entire XLEN sized word
was read, modified and written back.

NOTE: easiest way to avoid implementation issues is to not have side
effects on reads or writes of the previously read value in config registers

[source, C]
```
GPIOA->OUT |= (1<<13);
//is equivalent to
tio.sbseti io123, io123, 13
```

==== TODO: grouping of bits from multiple different registers

//bit views ???

For more efficient use of IO register space available by certain instructions.

Not reflecting actual memory mapped registers.

=== automatic mapping of memory mapped registers to tightly coupled registers

For efficient use (aka having it used at all) of the `tio` instructions, the compilers
need to automatically translate accesses to memory mapped registers into IO address space.

In case of avr8 the compiler received information about target mcu by the "-mcpu=" flag, for
automatic mapping of memory mapped peripherals into IO address space.
As the Atmel defacto controlled avr architecture, they had all of the possible IO mappings upstreamed.
Any chinese clone was cloning the IO address space layout of existing device exactly.

In case of risc-v we are about to end up with thousands of outdated custom toolchains. 
As is already happening with interrupt controllers (e.g. WCH hw stacking)

Therefore we need an unified file format describing peripheral to IO mapping, that will be provided by vendors. 
It will be passed to compiler command line similarly to source code or linker scripts.

NOTE: Those mapping files can be also self made in case of "typical chinese vendors"

==== TODO: define the iomapping file format

=== assembly syntax

All added instructions are prefixed with `tio.` prefix. +
Bank number is part of the instruction name. +
The suffix denominates wether `rd` or `rs1` field targets io registers +
Takes the form of `tio.instr{n}.{rd}{rs1}` where {n} is the bank number
and {rd} and {rs1} are substituted with one of the following letters .

- x - integer reg
- s - floating point reg
- y - io reg

Register specifiers use the same letter.

```
tio.sbseti3.yy y11, y11, 13 // set 13th bit in 12th io register in bank 3
tio.sbseti2.yx y22, zero, 17 // write (1<<17) to 23rd io register in bank 2
```

NOTE: letter y was picked totally arbitrarily as it's single letter and doesn't have conflicts

==== pseudoinstructions

`tio` instructions referred to without the bank number and suffix.

Pseudoinstructions use the `io` name prefix as the register specifier with
linearized addressing. The `.yy` form cannot cross the banks.

```
tio.sbseti io107, io107, 13 // set 13th bit in 12th io register in bank 3
tio.sbseti io86, zero, 17 // write (1<<17) to 23rd io register in bank 2
```

[[chapter_title]]
== XTightlyCoupledIO subextensions

The name `XTightlyCoupledIO` can be used as a catch all of following extensions.
	
=== XTightlyCoupledIOsupp

Supplementary instructions useful for alternative upper GPR approach.
Potentially usefull in non IO code.
	
=== XTightlyCoupledIOa

general IO alu and IO move, instructions

=== XTightlyCoupledIOsb

single bit IO access instructions

=== XTightlyCoupledIOsbbr

branch on single IO bit instriuctions

=== XTightlyCoupledIObf

IO destructive bitfield insert

=== XTightlyCoupledIOcm

implemented similarly to Zcm* extenaions, incompatible with Zcd

=== XTightlyCoupledIOother

other instructions that should be actually somewhere else

=== TODO: read and convert to float

readings are often immediately converted to float for processing in control loop algorithms

follow `fcvt.fmt.int` ??



[appendix]
= code samples


[appendix]
= test


Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x0, attr: ['yyy'] },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 7, name: 0x01, attr: ['aaa'] },
]}
....

costom 0 - 0b00 010 11 - 0x0b

custom 1 - 0b01 010 11 - 0x2b

custom 2 - 0b10 110 11 - 0x5b

custom 3 - 0b11 110 11 - 0x7b


[wavedrom, , svg]
....
{reg:[
    { bits:  2, name: 0x0, attr: ['C0'] },
    { bits:  11, name: '', attr: ['FLD'] },
    { bits:  3, name: 0b001, attr: ['FUNCT3'] },
],config:{bits:16}}
....

FSD - 101 00

FLDSP - 001 10

FSDSP allocated by Zce

[bibliography]
= Bibliography

* [[[spracw5a, 1]]] https://www.ti.com/lit/an/spracw5a/spracw5a.pdf