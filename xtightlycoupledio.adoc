
= XtightlyCoupledIO
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 0.19.3
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history


[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that reduces the duplications as those are hard to maintain.

There was no attempt at optimizing instruction encodings, (or packing them in less opcodes) 
other than sticking close to canonical risc-v encodings, yet.

The spec can be donated (FOSS org??), if it allows it to undergo more comparative studies and proceed to "standardization" 

[[chapter_title]]
== Introduction

The scope of XTightlyCoupledIO extension is to reduce code size, increase performance
in peripheral accessing code. It results in reduced latency in control loops etc.

This speec was created solely because we would have to wait for proprietary one otherwise.

And if we are talking about proprietary extensions, they are usually:

- Done wrong, mainly because specs are created on tight deadlines
- Not done at all (the most obvious and common approach)
- Those specs also almost never see an outside word and if they do, they are very badly 
documented or not documented at all (let's guess what custom instructions the ch32v003 or ch32v307 implements...)
- They also focus on gpio too much, leaving out the most frequently used or most critical peripherals. 

NOTE: In modern microcontroller codebases the gpio tends to become accessed less frequently
than other peripherals. And it's due to a simple reason - if the peripherals are 
present, they no longer have to be bit-banged by gpio as it was done in the past.

My observation of frequent peripheral patterns are:

- only single bit needs to be modified or branched on
- register is written with a heavy constant
- register written with zero
- in specific cases like STM32 BSRR or flag clearing, a single bit or inverted single bit constant is used
- the register content comes directly from/to memory
- otherwise the content is used in/comes from computations
- register content is immediately converted to float for computation

NOTE: In C/C++ the peripheral registers are marked as `volatile` which prevents many 
possible optimizations. The "side effecting" acceses must follow the source even though a 
single read + 2 single bit branches could be actually optimized into just two `tio.bsb*` instructions.

=== prior art

==== avr8

Provides 64 IO registers each being accesible by `in` and `out` instructions, 32 o them 
being available for the single bit instructions.
All registers are available through IO address space and memory addres space.

Single bit instructions consists of:

- `sbi` and `cbi` for setting and clearing bits
- `sbis` and `sbic` that can sip one instruction if IO bit is set/cleared
- `sbrc` and `sbrs` that can sip one instruction if bit in general purpose register is set/cleared

There are also `gpior` registers that serve as a scratch registers for e.g. global variables/flags. 
Those have to be used explicitly in source code.

.everything looks clean and nice but...

let's have a look on, how efficiently it's used:

atmega8::
- 3 reserved registers in bottom io space
- 8 non-bit registers in bottom io space 

atmega328p::
The most used chip in arduino, as well as the most cloned one. 
+
- 15 reserved registers in bottom io space
- 10 reserved registers in upper io space
- many registers available only as memory mapped

xmega::
- half of the bottom IO space is dedicated for `GPIO` (aka `gpior`) registers
- the other half is taken by VPORTs that can map to any gpio port configured
- area between 0x1f and 0x30 is not populated at all +
- 0x30 to 0x3f is populated by "CPU"
+
VPORTs have to be configured and used explicitly in source code.

AVR-DA::
One of the most recent avr8 family after Microchip.
+
similarly to xmega, there is only 7 GPIO virtual ports and 4 `GPR` (aka `gpior`) registers +
the upper part is populated only by the "CPU"

//???? There are 7 gpio ports and 7 virtual ones, are those actually mapped like 
//???? in the old avr or xmega (explicitly in source code)

==== ti PRU (in beaglebone sbcs)

r30 gpio output +
r31 gpio input

special instructions

==== ti c2/f2

<<spracw5a>> claims 2 cycle for ADC reg to float, Fig 4-3 claims 3x cycle speedup over cortex m4 (stm32g4)

==== ???

=== alternative approaches

==== map tu upper GPR

Available on RVE only. Limited to 16 GPR mapped registers.
Allows to recycle standard risc-v instructions operating on GPRs. 

==== use custom `csr` registers

csrr* instrtuctions implement an atomic swap and bitmask set/clear operations.

However `csr` registers are generally used to modify core architectural behaviour and thus perform slower than expected.

NOTE: for this reason RISC-V V spec forbids writes to `vtype` and `vl` with anything but `vsetvl` instructions

NOTE: xpulp extension is also planning on disallowing writes to hwloop registers with general csr instructions

==== bitbanding

Implemented by cortex-m3 and cortex-m4

Not available on cortex-m0 and cortex-m7, optional on cortex-m3/m4. +
Still requires loading of base address for bitbanded bit. 
Must be used explicitly in source code

==== special purpose write only registers

Special kind of write only registers e.g BSRR/IFCR found in STM32 and clones. +
Still require loading of peripheral base address. Requires also generating 
preformatted (shifted) constants even if only single bit is written.

NOTE: BSRR is still usefull for `tio.mv` acces as it can work on non-continous bitfields 
or content from pre generated lookup tables 

=== omitted instructions

NOTE: still available in first alternative approach

==== load to IO/store from IO register

Useful to directly store or load IO content to/from memory without processing.
It is also non deterministic and can trap due to e.g. alignment or pmp restrictions, violating atomicity guarantee.

==== IO with multiply/multiply-accumulate

Sometimes multi cycle, non deterministic.

Even single cycle implementations are potentially problematic to implement as 
the multiplier can span more pipeline stages than regular ALUs.

[[chapter_title]]
== programmers model

The XTightlyCoupledIO extension adds 4 banks of 32 XLEN sized IO registers each.
The IO registers are reffered from `rs1` and/or `rd` field. Named `ios1` and `iod`.

If a given bank is not populated, corresponding instructions are reserved.

Non-idempotent part of the IO targetting instructions must execute atomically.
Therefore those instructions cannot be interrupted with visible side-effects.

NOTE: number of banks and availability in certain instructions was decided
totally arbitrarily, will be refined later

NOTE: it is recommended to not keep registers mapped lienarly one after the other but 
split into appropriate banks. e.g. read/write data register doesn't need to live in a bit operable banks.

=== side effects

For easier mapping to high level languages, any access to IO registers causes
side effects as if the entire XLEN sized word was accessed.

A partial modification triggers side effects as if the entire XLEN sized word
was read, modified and written back.

[source, C]
```
GPIOA->OUT |= (1<<13);
//is equivalent to
tio.sbseti io123, io123, 13
```

==== TODO: grouping of bits from multiple different registers

//bit views ???

For more efficient use of IO register space available by certain instructions.

Not reflecting actual memory mapped registers.

==== TODO: multi core atomicity etc.

Core vs DMA is a likely scenario. +
In C the above RMW operation is non atomic. The tio isntructions can do atomic RMW what 
could lead to abuse of observed behaviour (bugs when porting from tio to non-tio mcu)

==== TODO: memory model of IO access

=== automatic mapping of memory mapped registers to tightly coupled registers

For efficient use (aka having it used at all) of the `tio` instructions, the compilers
need to automatically translate accesses to memory mapped registers into IO address space.

In case of avr8, the compiler received information about target mcu by the "-mcpu=" flag, for
automatic mapping of memory mapped peripherals into IO address space.
As the Atmel defacto controlled avr architecture, they had all of the possible IO mappings upstreamed.
Any chinese clone was cloning the IO address space layout of existing device exactly.

In case of risc-v we are about to end up with thousands outdated builds of custom toolchains. 
As is already happening with interrupt controllers (e.g. WCH hw stacking)

Therefore we need an unified file format describing peripheral to IO mapping, that will be provided by vendors. 
It will be passed to compiler command line similarly to source code or linker scripts.

NOTE: Those mapping files can be also self made in case of "typical chinese vendors"

NOTE: Those files could be used to provide named aliases in debuggers/decompilers

==== TODO: define the iomapping file format

==== TODO: named aliases for use in assembly

==== TODO: IO remap detection in assembly 

Even though compilers can automatically do a remap in compiled code, the assembly has
to explicitly use the dedicated IO instructions leading to unportable code.

NOTE: in theory load/store with absolute addressing mode can indeed be relaxed
into `in` and `out` instructions, but risc-v doesn't do an absolute addressing like avr8

In avr world portability of IO accesing assembly code was done like:

```
#if defined(atmega1234)||defined(atmega12345)

#define RDR_REGISTER_IN_IO
#define CONTROL1_REGISTER_IN_IO
#define CONTROL1_REGISTER_IN_LOWER_IO

#elif defined(atmega123456)
//...
```

And appropriately spam #ifdef's in the actual code.

As can be seen, each new device has to be added to the config header manually.

Therefore we need a way to discover wether given peripheral register is remapped 
into IO space, and use this information in e.g. #ifdefs

NOTE: assembly will stay messy with this anyway, especially when number of used 
register needs to be kept low in default inline interrupts

==== TODO: automatic mapping of globals to IO scratch registers

Apart from the peripherals, the IO address space can hold avr8 like
scratch registers. Those can be used to store the global variables/flags.

it can be:

* used explicitly like in avr8
** higly unportable
** falls into "premature optimization" category
** how many avr projects using `gpior` (aka `GPIO` aka `GPR`) did you see so far?

* automatically mapped to global variables/flags
** allows those scratch regs to be actually used
** no longer relaxable to gp-rel load/stores

* used with explicit attribute e.g. `\\__attribute__\((mapto_ioscratch("bsb_accessible,bool_mergable,1cycle")))`
** usefull for critical inner control loop globals
** can overide default cost function of above option
** variable is not forced into scratch register if specific criteria is not met
** no longer relaxable to gp-rel load/stores

=== assembly syntax

All IO accessing instructions are prefixed with `tio.` prefix. +
Bank number is part of the instruction name, except supplementary instructions. +
The suffix denominates wether `rd` or `rs1` field targets io registers +
Takes the form of `tio.instr{n}.{rdm}{rsm}` where {n} is the bank number
and {rdm} and {rsm} are substituted with one of the following letter.

- x - integer reg
- s - floating point reg
- y - io reg

//put it in separate section??
When {rdm} and {rsm} are present in instruction encodings, they control 
`rd` and `rs1` fields. If high the IO register in selected bank is targeted

Register specifiers use the same letter.

```
tio.sbseti3.yy y11, y11, 13 // set bit 13 in io 11 register in bank 3
tio.sbseti2.yx y22, zero, 17 // write (1<<17) to io 22 register in bank 2
```

NOTE: letter y was picked totally arbitrarily as it's single letter and doesn't have conflicts

==== pseudoinstructions

`tio` instructions referred to without the bank number and suffix.

Pseudoinstructions use the `io` name prefix as the register specifier with
linearized addressing. The `.yy` form cannot cross the banks.

```
tio.sbseti io107, io107, 13 // set bit 13 in io 11 register in bank 3
tio.sbseti io86, zero, 17 // write (1<<17) to io 22 register in bank 2
```

===== Canonical io move instruction

The following instructions are designated as a canonical IO move instructions:

```
tio.add{n}.yx iod, rs1, zero 
tio.add{n}.xy rd, ios1, zero
tio.add{n}.yy iod, ios1, zero // doesn't cross banks
```

Available under `tio.mv` name with suffixed or linearized version.

NOTE: The canonical move in base risc-v is an `addi`, but because of 
limited encoding, `tio.addi` cannot be provided with all necessary forms.
Therefore alternative instruction was picked.

NOTE: `tio.add` was picked because an addition is one of the most common 
operations and the add ALU tend's to be most available one. e.g. cortex-m7
doesn't provide bitwise and/or/xor in its early ALU

NOTE: the move to/form IO registeris are not named as `in` and `out`
as I find those names confusing

[[chapter_title]]
== XTightlyCoupledIO subextensions

The name `XTightlyCoupledIO` can be used as a catch all of following extensions.
	
NOTE: only the low 32bits of target register is accesible by branch instructions on rv64
	
=== XTightlyCoupledIOsupp

Supplementary instructions useful for alternative upper GPR approach.
Potentially usefull in non IO code.

==== tio.bsbseti.x

Synopsis::
Branch if single bit in register is set (immediate)

Mnemonic::
```
tio.bsbset.x rs1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

NOTE: instruction proposed as Zce 32bit candidate

==== tio.bsbclri.x

Synopsis::
Branch if single bit in register is cleared (immediate)

Mnemonic::
```
tio.bsbclr.x rs1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

NOTE: instruction proposed as Zce 32bit candidate

==== tio.bfinserti.xx

Synopsis::
Destructive bitfield insert into register (immediate)

Mnemonic::
```
tio.bfinserti.xx rd, rs1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: due to encoding constraints only destructive form is provided

NOTE: instruction was proposed for P extension as there are many more rd destructive ones 

==== tio.bfextracti.xx

Synopsis::
extract bitfield from register

Mnemonic::
```
tio.sbfextracti.xx rd, rs1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 0b00 },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: instruction is equivalent to `slli` + `srli` sequence

==== tio.sbfextracti.xx

Synopsis::
extract and sign extend bitfield from register

Mnemonic::
```
tio.sbfextracti.xx rd, rs1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b101 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 0b00 },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b101 },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: instruction is equivalent to `slli` + `srai` sequence

=== XTightlyCoupledIOa

general IO alu, instructions

The `.xx` form of those instructions is reserved

NOTE: the .yy form can be further limited to target only one IO register
for more efficient implementations

==== tio.addi.yx

Synopsis::
Add immediate and write to io register

Mnemonic::
```
tio.addi{bsel}.yx iod, rs1, imm
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 2, name: 0b00 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'rs1' },
 { bits: 12, name: 'imm[11:0]' },
]}
....

NOTE: `lui` + `tio.addi` pair can be used to write any 32bit constant into IO register.

==== tio.add

Mnemonic::
```
tio.add{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b000 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.sub

Mnemonic::
```
tio.sub{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b001 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== TODO: tio.rsub.{xy,yy}

not sure if actually usefull

==== tio.and

Mnemonic::
```
tio.and{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b010 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.or

Mnemonic::
```
tio.or{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b011 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.xor

Mnemonic::
```
tio.xor{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b100 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.sll

Mnemonic::
```
tio.sll{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b101 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.slli

Mnemonic::
```
tio.slli{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 3, name: 0b000 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 2, name: 0b00 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.srl

Mnemonic::
```
tio.srl{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b110 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.srli

Mnemonic::
```
tio.srli{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 3, name: 0b010 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 2, name: 0b01 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.sra

Mnemonic::
```
tio.sra{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b111 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.srai

Mnemonic::
```
tio.srli{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 3, name: 0b100 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b100 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 2, name: 0b10 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.slt.xy

Mnemonic::
```
tio.slt{bsel}.xy rd, ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b010 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0b01000 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.sltu.xy

Mnemonic::
```
tio.sltu{bsel}.xy rd, ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b010 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0b01001 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.sgt.xy

Mnemonic::
```
tio.sgt{bsel}.xy rd, ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b011 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0b01010 },
 { bits: 2, name: 'bsel' },
]}
....

NOTE: normally a pseudoinstrution by swapping rs1 and rs2 operands of slt instruction

==== tio.sgtu.xy

Mnemonic::
```
tio.sgtu{bsel}.xy rd, ios1, rs2
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b011 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0b01011 },
 { bits: 2, name: 'bsel' },
]}
....

NOTE: normally a pseudoinstrution by swapping rs1 and rs2 operands of sltu instruction

=== XTightlyCoupledIObb

general IO bitmanip, instructions

The `.xx` form of those instructions is reserved

NOTE: the .yy form can be further limited to target only one IO register
for more efficient implementations

==== tio.andn

Mnemonic::
```
tio.andn{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b010 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b010 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.orn

Mnemonic::
```
tio.orn{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b010 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b011 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.xnor

Mnemonic::
```
tio.xnor{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b010 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b100 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.rev8

Mnemonic::
```
tio.rev8{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b010 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b101 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.min

Mnemonic::
```
tio.min{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b010 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b110 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.minu

Mnemonic::
```
tio.minu{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b010 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b111 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.max

Mnemonic::
```
tio.max{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b011 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b000 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.maxu

Mnemonic::
```
tio.max{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32, RV64)::
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b011 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 3, name: 0b001 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

=== XTightlyCoupledIOsb

single bit IO access instructions

The `.xx` form of those instructions is reserved

NOTE: the .yy form can be further limited to target only one IO register
for more efficient implementations

==== tio.bseti

Synopsis::
Single bit set (immediate)

Mnemonic::
```
tio.bseti{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 3, name: 0b010 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 2, name: 0b01 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

NOTE: `tio.bseti` can be generate any single bit constant by using zero register

==== tio.bclri

Synopsis::
Single bit clear (immediate)

Mnemonic::
```
tio.bclri{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 3, name: 0b100 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 2, name: 0b10 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.binvi

Synopsis::
Single bit invert (immediate)

Mnemonic::
```
tio.binvi{bsel}.{x,y}{x,y} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 3, name: 0b110 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 2, name: 0b11 },
 { bits: 1, name: 'rsm' },
 { bits: 1, name: 'rdm' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.bexti.xy

Synopsis::
Single bit extract from IO register (immediate)

Mnemonic::
```
tio.bexti{bsel}.xy rd, ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'shamt' },
 { bits: 5, name: 0b01000 },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b000 },
 { bits: 5, name: 'ios1' },
 { bits: 6, name: 'shamt' },
 { bits: 4, name: 0b0100 },
 { bits: 2, name: 'bsel' },
]}
....

NOTE: on rv64 `tio.bexti` can reach the upper 32 bits in addition to `tio.bsb*` instructions

==== TODO: inverted single bit constant

We can achieve this in 2 instructions:

```
lui a0, %hi(~(1<<pos))
tio.addi iod, a0, %lo(~(1<<pos))
```
or
```
bseti a0, zero, shamt
tio.xnor iod, zero, a0
```

NOTE: Normally `xori rd, rs1, -1` is used for inversion.

==== TODO: reflect rest of the Zbs??

NOTE: probably not usefull, can be added for completness

=== XTightlyCoupledIOsbbr

branch on single IO bit instriuctions

==== tio.bsbseti.y

Synopsis::
Branch if single bit in IO register is set (immediate)

Mnemonic::
```
tio.bsbseti{bsel}.y ios1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 2, name: 0b10 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

==== tio.bsbclri.y

Synopsis::
Branch if single bit in IO register is cleared (immediate)

Mnemonic::
```
tio.bsbclri{bsel}.y ios1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x0b, attr: ['CUSTOM-0'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 2, name: 0b11 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

=== XTightlyCoupledIObf

IO destructive bitfield insert

==== tio.bfinserti.yx

Synopsis::
Destructive bitfield insert into IO register (immediate)

Mnemonic::
```
tio.bfinserti{bsel}.yx iod, rs1, shamt, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0b001 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 2, name: 0b01 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: due to encoding constraints only destructive form is provided

NOTE: rv64 encoding could tradeoff the extra len/offset range similarly to branches

==== tio.bfextracti.xy

Synopsis::
extract bitfield from IO register

Mnemonic::
```
tio.bfextracti{bsel}.xy rd, ios1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b010 },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b10 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

NOTE: instruction is equivalent to `tio.slli` + `srli` sequence

==== tio.sbfextracti.xy

Synopsis::
extract and sign extend bitfield from IO register

Mnemonic::
```
tio.sbfextracti{bsel}.xy rd, ios1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b011 },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0b11 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

NOTE: instruction is equivalent to `tio.slli` + `srai` sequence

=== XTightlyCoupledIOcm

implemented similarly to Zcm* extenaions, incompatible with Zcd

==== tio.cm.mv.yx

Synopsis::
Move into IO register

Mnemonic::
```
tio.cm.mv{bsel}.yx iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits:  2, name: 0b00, attr: ['C0'] },
 { bits:  5, name: 'rs2' },
 { bits:  5, name: 'iod' },
 { bits:  1, name: 'bsel' },
 { bits:  3, name: 0b101, attr: ['FSD'] },
],config:{bits:16}}

....

NOTE: not symmetric with canonical move

==== tio.cm.mv.xy

Synopsis::
Move from IO register

Mnemonic::
```
tio.cm.mv{bsel}.xy rd, ios1
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits:  2, name: 0b10, attr: ['C2'] },
 { bits:  5, name: 'ios1' },
 { bits:  5, name: 'rd' },
 { bits:  1, name: 'bsel' },
 { bits:  3, name: 0b001, attr: ['FLDSP'] },
],config:{bits:16}}
....

NOTE: ios1 in rs2 position, the low bits store only rd' in C extension, maybe swap?

==== tio.cm.bseti0.yy

Synopsis::
Set bit in IO register (immediate)

Mnemonic::
```
tio.cm.bseti0.yy iod, shamt
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits:  2, name: 0b00, attr: ['C0'] },
 { bits:  5, name: 'shamt' },
 { bits:  5, name: 'iod' },
 { bits:  1, name: '0' },
 { bits:  3, name: 0b001, attr: ['FLD'] },
],config:{bits:16}}

....

NOTE: only bottom 32 bits are accessible

==== tio.cm.bclri0.yy

Synopsis::
Clear bit in IO register (immediate)

Mnemonic::
```
tio.cm.bclri0.yy iod, shamt
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits:  2, name: 0b00, attr: ['C0'] },
 { bits:  5, name: 'shamt' },
 { bits:  5, name: 'iod' },
 { bits:  1, name: '1' },
 { bits:  3, name: 0b001, attr: ['FLD'] },
],config:{bits:16}}

....

NOTE: only bottom 32 bits are accessible

=== XTightlyCoupledIOfcvt

implemented similarly to F or Zfinx fcvt instructions

NOTE: readings are often immediately converted to float for processing in control loop algorithms

==== tio.fcvt.s.w.sy

Synopsis::
Read IO register and convert to float

Mnemonic::
```
tio.fcvt{bsel}.s.w.sy rd, ios1, rm
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-3'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 'rm' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 0b00000 },
 { bits: 2, name: 'fmt', attr: ['S'] },
 { bits: 3, name: 0b000 },
 { bits: 2, name: 'bsel[1:0]' },
]}
....

Prerequisites::
F or Zfinx

==== tio.fcvt.s.wu.sy

Synopsis::
Read IO register and convert to float

Mnemonic::
```
tio.fcvt{bsel}.s.wu.sy rd, ios1, rm
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-3'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 'rm' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 0b00001 },
 { bits: 2, name: 'fmt', attr: ['S'] },
 { bits: 3, name: 0b000 },
 { bits: 2, name: 'bsel[1:0]' },
]}
....

Prerequisites::
F or Zfinx

==== TODO: double precision and rv64
//need to reduce duplication

==== TODO: float to int

potentially problematic to implement, as the float pipe 
is usually longer than integer one

[appendix]
= code samples


[bibliography]
= Bibliography

* [[[spracw5a, 1]]] https://www.ti.com/lit/an/spracw5a/spracw5a.pdf