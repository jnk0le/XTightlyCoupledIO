
= XtightlyCoupledIO
Jan Oleksiewicz <jnk0le@hotmail.com>
:appversion: 3.0.1
:toc:
:toclevels: 4
:sectnums:


{author} {email} +
document version {appversion} +
extension status: unstable/PoC +
This document is released under a Creative Commons Attribution 4.0 International License

[colophon]
== revision history

[width="100%",options=header]
|====================================================================================
| Version | change
| v3.0.1  | fixed typos
| v3.0.0  | rework of encodings, removed destructive shifts and `beq.y`/`bne.y`
            canonical move into IO uses rs2 for symmetry with compressed encoding
| v2.8.1  | fixed offset field name in bfinserti.yx
| v2.8.0  | added fence interop
| v2.7.4  | some of 8051 SFRs are preoccupied
| v2.7.3  | fixed bibliography links
| v2.7.2  | avr io address space is smaller than 8051 SFRs
| v2.7.1  | added 8051 prior and extra avr8 commentary
| v2.7.0  | added relaxation section, supplementary instrs can also pseudoinstr
| v2.6.2  | added rationale for removal of .yy encodings
| v2.6.1  | added PIO prior
| v2.6.0  | added sideOPdelay subextension
| v2.5.1  | fixed naming of bitfield positions in samples
| v2.5.0  | initial memory model
| v2.4.2  | update appendix with new bitield instructions
| v2.4.1  | missing bsel, typo fix
| v2.4.0  | added bitfield insert from immediate
| v2.3.0  | use `.xi` suffix for reg-imm beqi
| v2.2.1  | added description to less obvious instructions, some fixes
| v2.2.0  | added `tio.beqi.x` and `tio.bnei.x`
| v2.1.8  | cm0+ single cycle IO
| v2.1.7  | 47999 is upper compressible
| v2.1.6  | added simple pin toggle sample
| v2.1.5  | better sequence for inverted single bit, other improvements
| v2.1.4  | fixed 7segment tio code
| v2.1.3  | consistently apply compression for all `tio.bseti`/`tio.bclri`
| v2.1.2  | added 7segment init sample
| v2.1.1  | minor editorial improvements
| v2.1.0  | added `tio.beq` and `tio.bne`
| v2.0.1  | fixed wavedrom rendering
| v2.0.0  | major rework of encodings, the `.yy` is now destructive `.y` form,
            removed `tio.slt`/`tio.sgt` instructions, shuffled subetensions,
            added reg-reg single bit instructions, minor fixes
| v1.0.39 | added tio implementation of second pll config, some fixes
| v1.0.38 | properly implemented init_clocks2()
| v1.0.37 | fixed FLASH_ACR setup
| v1.0.36 | fixed mask gen for zoroed register
| v1.0.35 | fixed mask clearing in sample
| v1.0.34 | added tio sample for a first appendix scenario
| v1.0.33 | initial appendix scanario placeholder
| v1.0.32 | sync cm destructive specifier with C extension
| v1.0.31 | cm instruction require Zca
| v1.0.30 | rendering fix
| v1.0.29 | various editorial improvements
| v1.0.28 | typo fix
| v1.0.27 | fixed bfinserti.xx encoding
| v1.0.26 | moved inverted single bit into ommitted instructions
| v1.0.25 | removed "rest of zbs" section
| v1.0.24 | removed rsub section
| v1.0.23 | moved note to more appropriate section
| v1.0.22 | just execute atomially
| v1.0.21 | fixed bsbseti/bsbclri instruction mnemonics
| v1.0.20 | typo fix
| v1.0.19 | typo fix
| v1.0.18 | typo fix
| v1.0.17 | improvements on volatile limitation notes
| v1.0.16 | added section about AMO-op alt approach
| v1.0.15 | fixed bfextracti.xy rv64 encoding
| v1.0.14 | fixed mnemonic and rv64 encoding of tio.(s)bfextracti.xx instructions
| v1.0.13 | improved rationale text
| v1.0.12 | not probably mapped
| v1.0.11 | avr io mapping is much simpler
| v1.0.10 | finally fixed all wavedrom rendering issues
| v1.0.9  | inverted single bit in one instruction
| v1.0.8  | sync bsel description
| v1.0.7  | fixed funct3 encodings of extract instructions
| v1.0.6  | removed redundant note, improved spelling
| v1.0.5  | add note about bit accesibility in bsb instructions
| v1.0.4  | fixed wavedrom rendering
| v1.0.3  | setup revision history table
| v1.0.2  | typo fix
| v1.0.1  | extra text about heavy constants
| v1.0.0  | first public release
|====================================================================================

[colophon]
== preface

This document uses semantic versioning with respect to potential hardware designs. 
Assembly syntax change is a minor increment. Version 1.0.0 is the first publicly released. 
Changes in prior versions are not versioned properly and not tracked in revision history.

Document is written in a way that reduces the duplications as those are hard to maintain.

There was no attempt at optimizing instruction encodings, other than sticking 
close to canonical risc-v encodings, yet.

The spec can be donated (FOSS org??), if it allows it to undergo more comparative studies and proceed to "standardization" 

== Introduction

The scope of XTightlyCoupledIO extension is to reduce code size, register pressure and increase performance
in peripheral accessing code. All of which results in reduced latency in control loops etc.

This spec was created solely because we would have to wait for proprietary one otherwise.

And if we are talking about proprietary extensions, they are usually:

- Done wrong, mainly because specs are created on tight deadlines without community feedback
(like the severely missing instructions in XTheadBs)
- Not done at all (the most obvious and common approach)
- Those specs also almost never see an outside word and if they do, they are very badly 
documented or not documented at all (let's guess what custom instructions the ch32v003 or ch32v307 implements...)
- They also focus on gpio too much, leaving out the most frequently used or most critical peripherals. 

NOTE: In modern microcontroller codebases the gpio tends to become accessed less frequently
than other peripherals. And it's due to a simple reason - if the peripherals are 
present, they no longer have to be bit-banged by gpio as it was done in the past.

My observation of frequent peripheral patterns are:

- only single bit needs to be modified or branched on
- register is written with a heavy constant (including memory addresses)
- register written with zero
- in specific cases like STM32 BSRR or flag clearing, a single bit or inverted single bit constant is used
- the register content comes directly from/to memory
- otherwise the content is used in/comes from computations
- register content is immediately converted to float for computation
- small bitfields are extracted or inserted from/to registers

NOTE: Also the C/C++ `volatile` specifier prevent many possible compiler optimizations. 
The "side effecting" acceses must follow what was written in the source code exactly, even though a 
read + 2 single bit branches could be actually optimized into just two `tio.bsb*.y` instructions.
There is no way to distinguish if the intent was to avoid side effects, taking snapshot of status flags in time
or just an optimization for typical architectures.

=== prior art

==== avr8

Provides 64 IO registers each being accesible by `in` and `out` instructions, 32 of them 
being available for the single bit instructions.
All registers are available through IO address space and memory addres space.

Single bit instructions consists of:

- `sbi` and `cbi` for setting and clearing IO bits
- `sbis` and `sbic` that can skip one instruction if IO bit is set/cleared
- `sbrc` and `sbrs` that can skip one instruction if bit in general purpose register is set/cleared

There are also `gpior` registers that serve as a scratch registers for e.g. global variables/flags. 
Those have to be used explicitly in source code.

.everything looks clean and nice but...

let's have a look on, how efficiently it's used:

atmega8::
- 3 reserved registers in bottom io space
- 8 non-bit registers in bottom io space 

atmega328p::
The most used chip in arduino, as well as the most cloned one. 
+
- 15 reserved registers in bottom io space
- 10 reserved registers in upper io space
- many registers available only as memory mapped

xmega::
- half of the bottom IO space is dedicated for `GPIO` (aka `gpior`) registers
- the other half is taken by VPORTs that can map to any gpio port configured
- area between 0x1f and 0x30 is not populated at all +
- 0x30 to 0x3f is populated by "CPU"
+
VPORTs have to be configured and used explicitly in source code.

AVR-DA::
One of the most recent avr8 family after Microchip.
+
similarly to xmega, there is only 7 GPIO virtual ports and 4 `GPR` (aka `gpior`) registers +
the upper part is populated only by the "CPU"

//???? There are 7 gpio ports and 7 virtual ones, are those actually mapped like 
//???? in the old avr or xmega (explicitly in source code)

It is also worth to mention that avr8 architecture has not been licensed to 3rd parties
like the 8051 did. Even though it could offer better PPA and development ease than average "1T" 8051.
Today we have only a few chinese clones of atmega328p due to expired patents. +
<<doc1292>> compares various architectures over presumably pure 8bit applications.
It is unknown if peripherals in io address space was used on avr.

==== ti PRU (in beaglebone sbcs)

only the GPIO pins are mapped to r30 and r31 register.

special instructions for:

- set/clear bit
- branch if bit is set/cleared

==== ti c2000

<<spracw5a>> claims 2 cycles for ADC reg to float, Fig 4-3 claims 3x cycle speedup over cortex m4 (stm32g4)

==== cortex m0+ single cycle IO

Uses exactly the same code of memory mapped IO but the loads and stores execute in 1 cycle instead of 2 cycles

==== PIO (in RP2040)

Reffered to as a programmable state machine, able to emulate serial and parallel
peripherals over GPIO. Very limited instruction set.

Assumes cycle accurate, single cycle micro architecture. +
Has an optional "side-set" operation and delay which stall execution of any following instruction.

==== 8051

8051 dedicates half of IRAM address space (aka zero page) for IO SFRs.
SFRs are not available by indirect addressing as it targets the "hidden" SRAM.

0x20-0x2F memory range is bit-addressable.
8 vertical (0x80, 0x88, 0x90...) SFR registers are bit addressable.
Some of them are pre-occupied by (mandatory) standard SFRs, including the accumulator `A` and
less usefull `B`.

bit-addressable registers can be operated by special irregular instructions:

- set/clear/complement bit
- jump if bit is set/clear
- jump if bit is set then clear it
- `mov` between bit and carry flag
- `and`/`or` operation of carry into bit (or its inverse)

=== alternative approaches

==== map to upper GPR

Available on RVE only. Limited to 16 GPR mapped registers.
Allows to recycle standard risc-v instructions operating on GPRs. 

==== use custom `csr` registers

csrr* instrtuctions implement an atomic swap and bitmask set/clear operations.

However `csr` registers are generally used to modify core architectural behaviour and thus perform slower than expected.

NOTE: for this reason RISC-V V spec forbids writes to `vtype` and `vl` with anything but `vsetvl` instructions

NOTE: xpulp extension is also planning on disallowing writes to hwloop registers with general csr instructions

==== bitbanding

Implemented by cortex-m3 and cortex-m4

Not available on cortex-m0 and cortex-m7, optional on cortex-m3/m4. +
Still requires loading of base address for bitbanded bit. 
Must be used explicitly in source code

==== special purpose write only registers

Special kind of write only registers e.g BSRR/IFCR found in STM32 and clones. +
Still require loading of peripheral base address. Requires also generating 
preformatted (shifted) constants even if only single bit is written.

NOTE: BSRR is still usefull for `tio.mv` acces as it can work on non-continous bitfields 
or content from pre generated lookup tables 

==== use reserved registers in ABI deviations

Similar to ti PRU approach.

Only a few registers can be reserved like that. It takes out general purpose registers 
from use leading to less efficient code.

NOTE: ABI deviations is not standardized at this moment

==== use AMO-op instructions

There is limited availability of A extension acros embedded cores.

Still requires loading of base address. +
Base address must be generated with full `lui` + `addi` sequence as there is no immediate offset 
like in regular load/store instructions. +
Implements only swap/add/or/and/xor/min/max operations.

=== omitted instructions

NOTE: still available in first alternative approach as well as ABI deviations one

==== load to IO/store from IO register

Useful to directly store or load IO content to/from memory without processing.
It is also non deterministic and can trap due to e.g. alignment or pmp restrictions, violating atomicity guarantee.
Those also would consume a lot of encoding space.

==== IO with multiply/multiply-accumulate

Usefull for fixed point arithmetic scaling etc.

Sometimes multi cycle, non deterministic.

Even single cycle implementations are potentially problematic to implement as 
the multiplier can span more pipeline stages than regular ALUs.

NOTE: if the `mulh` is necessary the `tio.mul` becomes useless 

NOTE: P ext like, `tio.mull.xy` with destination register pair should still be possible 

==== inverted single bit constant

Low use cases to be worth.

Bottom 11 bits can be done with single instruction:

```
tio.addi iod, zero, (~(1<<pos))
```

Otherwise we can achieve this in 2 instructions:

```
lui t0, %hi(~(1<<pos)) // 'c.' if bit 16-12 zeoroed 
tio.addi iod, t0, %lo(~(1<<pos))
```
or
```
c.li t0, -1
tio.bclri iod, t0, pos
```

==== non destructive io-io-reg instructions

Low use cases of independent io to io moves/ops.

Low flexibility of implementations, as the non destructive ops cannot 
provide AMO like decoupled execution.

NOTE: Destructive encodings are also justified by a bitfield insert instructions,
possible only within destructive encoding. 

== programmers model

The XTightlyCoupledIO extension adds 4 banks of 32 XLEN sized IO registers each.
The IO registers are reffered from `rs1` or `rd` field. Named `ios1` and `iod`.

If a given bank is not populated, corresponding instructions are reserved.

The IO targetting instructions must execute atomically.
Therefore those instructions cannot be interrupted with visible side-effects.

NOTE: number of banks and availability in certain instructions was decided
totally arbitrarily, will be refined later

=== side effects

For easier mapping to high level languages, any access to IO registers causes
side effects as if the entire XLEN sized word was accessed.

A partial modification triggers side effects as if the entire XLEN sized word
was read, modified and written back.

[source, C]
```
GPIOA->OUT |= (1<<13);
//is equivalent to
tio.bseti io123, 13
```

==== TODO: grouping of bits from multiple different registers

//bit views ???

For more efficient use of IO register space available by certain instructions.

Not reflecting actual memory mapped registers.

==== memory model of IO access

The access to IO registers by `tio.` instructions, follows the TSO moemory model with respect to each other.
The repeated accesses to the same IO register is sequentially consistent.

NOTE: TSO model is the best fit for typicall in-order pipelines longer than 2-3 stages

NOTE: implementations cannot reuse operand forwarding to solve RAW hazards of IO registers
due to `volatile` rules

Access to IO registers by `tio.` instructions and memory mapped interface is not synchronized.

NOTE: it would be too expensive to sync read-ALU-writeback stages with memory interface

NOTE: implementations are still free to microcode `tio.` instructions using memory load and store

==== `fence` interop

`fence` instruction orders access of `tio.` instructions using the PI/PO/SI/SO fields. +
RMW operation is interpreted as combined read and write.

It must also properly order `tio.` accesses with respect to memory mapped IO, that use the same PI/PO/SI/SO fields.

NOTE: it was decided to not extend `fence` instruction, due to limited use cases

=== automatic mapping of memory mapped registers to tightly coupled registers

For efficient use (aka having it used at all) of the `tio` instructions, the compilers
need to automatically translate accesses to memory mapped registers into IO address space.

In case of avr8, the IO address space was mapped linearly to a specific offset 
in data address space (+0x20).

In case of arm or risc-v the peripherals are scattered over large memory area
with 1024 byte minimum spacing. Because of this there needs to be a special mapping 
into IO address space and we are about to end up with thousands (sometimes GPL 
violating) outdated builds of custom toolchains, for all of those.
As is already happening with interrupt controllers (e.g. WCH hw stacking)

Therefore we need an unified file format describing peripheral to IO mapping, that will be provided by vendors. 
It will be passed to compiler command line similarly to source code or linker scripts.

NOTE: Those mapping files can be also self made in case of "typical chinese vendors"

NOTE: Those files could be used to provide named aliases in debuggers/decompilers

NOTE: it is recommended to not keep registers mapped lienarly one after the other but 
split into appropriate banks. e.g. read/write data register doesn't need to live in a bit operable banks.

==== TODO: define the iomapping file format

==== TODO: named aliases for use in assembly

==== TODO: IO remap detection in assembly 

Even though compilers can automatically do a remap in compiled code, the assembly has
to explicitly use the dedicated IO instructions leading to unportable code.

NOTE: in theory load/store with absolute addressing mode can indeed be relaxed
into `in` and `out` instructions, but risc-v doesn't do an absolute addressing like avr8

In avr world portability of IO accesing assembly code was done like:

```
#if defined(atmega1234)||defined(atmega12345)

#define RDR_REGISTER_IN_IO
#define CONTROL1_REGISTER_IN_IO
#define CONTROL1_REGISTER_IN_LOWER_IO

#elif defined(atmega123456)
//...
```

And appropriately spam #ifdef's in the actual code.

As can be seen, each new device has to be added to the config header manually.

Therefore we need a way to discover wether given peripheral register is remapped 
into IO space, and use this information in e.g. #ifdefs

NOTE: assembly will stay messy with this anyway, especially when number of used 
register needs to be kept low in default inline interrupts

==== TODO: automatic mapping of globals to IO scratch registers

Apart from the peripherals, the IO address space can hold avr8 like
scratch registers. Those can be used to store the global variables/flags.

it can be:

* used explicitly like in avr8
** higly unportable
** falls into "premature optimization" category
** how many avr projects using `gpior` (aka `GPIO` aka `GPR`) did you see so far?

* automatically mapped to global variables/flags
** allows those scratch regs to be actually used
** no longer relaxable to gp-rel load/stores

* used with explicit attribute e.g. `\\__attribute__\((mapto_ioscratch("bsb_accessible,bool_mergable,1cycle")))`
** usefull for critical inner control loop globals
** can overide default cost function of above option
** variable is not forced into scratch register if specific criteria is not met
** no longer relaxable to gp-rel load/stores

=== assembly syntax

All IO accessing instructions are prefixed with `tio.` prefix. +
Bank number is part of the instruction name, except supplementary instructions. +
The suffix denominates wether `rd` or `rs1` field targets io registers +
Takes the form of `tio.instr{n}.{rdm}{rsm}` where {n} is the bank number
and {rdm} and {rsm} are substituted with one of the following letter.

- x - integer reg
- s - floating point reg
- y - io reg

Register specifiers use the same letter.

```
tio.bseti3.y y11, 13 // set bit 13 in io 11 register in bank 3
tio.bseti2.yx y22, zero, 17 // write (1<<17) to io 22 register in bank 2
```

NOTE: letter y was picked totally arbitrarily as it's single letter and doesn't have conflicts

==== pseudoinstructions

`tio` instructions referred to without the bank number and suffix.

Pseudoinstructions use the `io` name prefix as the register specifier with
linearized addressing.

The supplementary instructions with omitted suffix are also considered as pseudoinstructions.

```
tio.bseti io107, 13 // set bit 13 in io 11 register in bank 3
tio.bseti io86, zero, 17 // write (1<<17) to io 22 register in bank 2
```

==== Canonical io move instruction

The following instructions are designated as a canonical IO move instructions:

```
tio.add{n}.yx iod, zero, rs2
tio.add{n}.xy rd, ios1, zero
```

Available under `tio.mv` name with suffixed or linearized version.

NOTE: The canonical move in base risc-v is an `addi`, but because of 
limited encoding, `tio.addi` cannot be provided with all necessary forms.
Therefore alternative instruction was picked.

NOTE: `tio.add` was picked because an addition is one of the most common 
operations and the add ALU tend's to be most available one. e.g. cortex-m7
doesn't provide bitwise and/or/xor in its early ALU

NOTE: the move to/from IO registeris are not named as `in` and `out`
as I find those names confusing

==== code relaxation (aka compression)

Only the pseudo instructions are allowed to be relaxed into a different
instruction, be it compressed or different one of the same size.

NOTE: BTW, this is how it should be done with base riscv instructions
where e.g. `i.add a0, a0, a1` must alway emit exactly specified encoding
and `add a0, a0, a1` can be relaxed to compressed instruction or a different one
(e.g. `bseti a0, a1, 11` can be turned into `ori a0, a1, (1<<11)` for assumed,
better execution units availability).
For now we have only the unreliable and bloaty `.option norvc` workaround.

==== sideOP

sideOP value can be optionally encoded by value placed in square brackets that is 
placed after the last instruction param, separated by comma.
If ommited the value `0` is encoded.

If an extension choses to use different syntax than plain `uimm[4:0]` constant,
it must be placed within the square bracket.

If square bracket is provided with a single number, it must always be interpreted as `uimm[4:0]` constant

usage::
[source, asm]
```
1:	tio.bseti GPIOA_ODR, 13
2:	tio.bseti GPIOA_ODR, 13, [0] // equivalent to 1
3:	tio.bseti GPIOA_ODR, 13, [31]
4:	tio.bseti GPIOA_ODR, 13, [sideset 0b10, 7] // imaginary extension
```

NOTE: Square bracket was selected as MIPS syntax inherited by RISC-V doesn't use those.

NOTE: pioasm use it for delay only, not separated by comma from rest of the instruction params.

=== instruction encodings

When `iom` bit is present, it controls wether `rd` or `rs1` targets IO register. +
When high the rd field targets IO register. When low, the rs1 field targets the IO register.

`bsel` immediate selects the accessed bank number. Bits missing from encodings are implied to be zero.

`sideOP` encodes a side operation, that will be a part of another extension. Otherwise this field is reserved 
and must be set to `0b00000` (no extra operation)

[[chapter_title]]
== XTightlyCoupledIO subextensions

The name `XTightlyCoupledIO` can be used as a catch all of following extensions.

=== XTightlyCoupledIOsupp

Supplementary instructions useful for alternative upper GPR approach.

Necessary when working on "cached" IO register content, as those cannot be 
accessed multiple times due to `volatile` rules.

NOTE: usefull also in non IO code.

==== tio.bsbseti.x

Synopsis::
Branch if single bit in register is set (immediate)

Mnemonic::
```
tio.bsbseti.x rs1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x7b, attr: ['CUSTOM-3'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

NOTE: instruction proposed as Zce 32bit candidate

NOTE: only bottom 32 bits of target register are accessible on rv64

==== tio.bsbclri.x

Synopsis::
Branch if single bit in register is cleared (immediate)

Mnemonic::
```
tio.bsbclri.x rs1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x7b, attr: ['CUSTOM-3'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

NOTE: instruction proposed as Zce 32bit candidate

NOTE: only bottom 32 bits of target register are accessible on rv64

==== tio.bfextracti.xx

Synopsis::
extract bitfield from register (immediate)

Mnemonic::
```
tio.bfextracti.xx rd, rs1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 0x0 },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: instruction is equivalent to `slli` + `srli` sequence

==== tio.sbfextracti.xx

Synopsis::
extract and sign extend bitfield from register (immediate)

Mnemonic::
```
tio.sbfextracti.xx rd, rs1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 0x0 },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: instruction is equivalent to `slli` + `srai` sequence

=== XTightlyCoupledIOsuppbfi

Supplementary bitfield insert useful for alternative upper GPR approach.

Necessary when working on "cached" IO register content, as those cannot be 
accessed multiple times due to `volatile` rules.

==== tio.bfinserti.xx

Synopsis::
Destructive bitfield insert into register (immediate)

Mnemonic::
```
tio.bfinserti.xx rd, rs1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x0 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 0x0 },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x0 },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: due to encoding constraints only destructive form is provided

NOTE: instruction was proposed for P extension as there are many more rd destructive ones 

==== tio.bfinserti.xi

Synopsis::
Destructive bitfield insert into register from immediate (immediate)

Mnemonic::
```
tio.bfinserti.xi rd, uimm, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'uimm[4:0]' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 0x0 },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'uimm[4:0]' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

Description::
Insert `len` bits of expanded 'uimm[4:0]' constant into rd register at `offset` position.
The `uimm=0` is mapped into `-1` constant.

NOTE: due to encoding constraints only destructive form is provided

=== XTightlyCoupledIOsuppbri

Supplementary instructions for branching against immediate

Necessary for branching on exact pattern match of extracted bitfields.

NOTE: xpulp does signed immediate in rs2 position, meanwhile Zce v0.50 puts nzuimm in rs1 position

NOTE: `uimm=0` can be expressed with `beq/bne zero, rs2, label` therefore this case can
be reserved or mapped to other constant

NOTE: `uimm` from rs1 position was selected as it is already used by `csrr*i` as well as `vsetivli` instructions

NOTE: usefull also for lowering general code size and register pressure (for e.g. rv32e or IPRA compilation), 

==== tio.beqi.xi

Synopsis::
Branch if equal (immediate)

Mnemonic::
```
tio.beqi.xi rs2, uimm, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x63, attr: ['BRANCH'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'uimm[4:0]' },
 { bits: 5, name: 'rs2' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

Description::
Branch to `label` if rs2 content is equal to expanded 'uimm[4:0]' constant.
The `uimm=0` is mapped into `-1` constant.

==== tio.bnei.xi

Synopsis::
Branch if not equal (immediate)

Mnemonic::
```
tio.bnei.xi rs2, uimm, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x63, attr: ['BRANCH'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'uimm[4:0]' },
 { bits: 5, name: 'rs2' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

Description::
Branch to `label` if rs2 content is not equal to expanded 'uimm[4:0]' constant.
The `uimm=0` is mapped into `-1` constant.


=== XTightlyCoupledIOaddi

Single IO `addi` instruction provided for minimal implementations

==== tio.addi.yx

Synopsis::
Add immediate and write to io register

Mnemonic::
```
tio.addi{bsel}.yx iod, rs1, imm
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 2, name: 0x0 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'rs1' },
 { bits: 12, name: 'imm[11:0]' },
]}
....

NOTE: `lui` + `tio.addi` pair can be used to write any 32bit constant into IO register.

=== XTightlyCoupledIOa

General IO alu instructions

==== tio.add

Mnemonic::
```
tio.add{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x0 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.sub

Mnemonic::
```
tio.sub{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x1 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.and

Mnemonic::
```
tio.and{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x2 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.or

Mnemonic::
```
tio.or{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x3 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.xor

Mnemonic::
```
tio.xor{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x4 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.slli

Mnemonic::
```
tio.slli{bsel}.{xy,yx} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x3 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 3, name: 0x3 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.srli

Mnemonic::
```
tio.srli{bsel}.{xy,yx} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x4 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 3, name: 0x4 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.srai

Mnemonic::
```
tio.srai{bsel}.{xy,yx} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x5 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 3, name: 0x5 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.sll

Mnemonic::
```
tio.sll{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x3 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.srl

Mnemonic::
```
tio.srl{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x4 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.sra

Mnemonic::
```
tio.sra{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x5 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

=== XTightlyCoupledIOad

Destructive general IO alu instructions

==== tio.add.y

Mnemonic::
```
tio.add{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x0 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.sub.y

Mnemonic::
```
tio.sub{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x1 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.and.y

Mnemonic::
```
tio.and{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x2 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.or.y

Mnemonic::
```
tio.or{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x3 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.xor.y

Mnemonic::
```
tio.xor{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x4 },
 { bits: 2, name: 'bsel' },
]}
....

=== XTightlyCoupledIObb

General IO bitmanip instructions

==== tio.andn

Mnemonic::
```
tio.andn{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x5 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.orn

Mnemonic::
```
tio.orn{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x6 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.xnor

Mnemonic::
```
tio.xnor{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x7 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.min

Mnemonic::
```
tio.min{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x8 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.minu

Mnemonic::
```
tio.minu{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0x9 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.max

Mnemonic::
```
tio.max{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0xa },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.maxu

Mnemonic::
```
tio.maxu{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0xb },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.rev8

Mnemonic::
```
tio.rev8{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x1 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 4, name: 0xc },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

=== XTightlyCoupledIObbd

Destructive general IO bitmanip instructions

==== tio.andn.y

Mnemonic::
```
tio.andn{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x5 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.orn.y

Mnemonic::
```
tio.orn{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x6 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.xnor.y

Mnemonic::
```
tio.xnor{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x7 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.min.y

Mnemonic::
```
tio.min{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x8 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.minu.y

Mnemonic::
```
tio.minu{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0x9 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.max.y

Mnemonic::
```
tio.max{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0xa },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.maxu.y

Mnemonic::
```
tio.maxu{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 5, name: 0xb },
 { bits: 2, name: 'bsel' },
]}
....

=== XTightlyCoupledIOsb

Single bit IO access instructions

==== tio.bseti

Synopsis::
Single bit set (immediate)

Mnemonic::
```
tio.bseti{bsel}.{xy,yx} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x0 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 3, name: 0x0 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.bclri

Synopsis::
Single bit clear (immediate)

Mnemonic::
```
tio.bclri{bsel}.{xy,yx} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x1 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 3, name: 0x1 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.binvi

Synopsis::
Single bit invert (immediate)

Mnemonic::
```
tio.binvi{bsel}.{xy,yx} rd/iod, rs1/ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x2 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 3, name: 0x2 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.bexti.xy

Synopsis::
Single bit extract from IO register (immediate)

Mnemonic::
```
tio.bexti{bsel}.xy rd, ios1, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x6 },
 { bits: 1, name: 0, attr: ['iom'] },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x3 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 6, name: 'shamt' },
 { bits: 3, name: 0x6 },
 { bits: 1, name: 0, attr: ['iom'] },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.bset

Synopsis::
Single bit set

Mnemonic::
```
tio.bset{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x0 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.bclr

Synopsis::
Single bit clear

Mnemonic::
```
tio.bclr{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x1 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.binv

Synopsis::
Single bit invert

Mnemonic::
```
tio.binv{bsel}.{xy,yx} rd/iod, rs1/ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x2 },
 { bits: 1, name: 'iom' },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.bext.xy

Synopsis::
Single bit extract from IO register

Mnemonic::
```
tio.bext{bsel}.xy rd, ios1, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod/rd' },
 { bits: 3, name: 0x2 },
 { bits: 5, name: 'ios1/rs1' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 3, name: 0x6 },
 { bits: 1, name: 0, attr: ['iom'] },
 { bits: 2, name: 'bsel' },
]}
....


=== XTightlyCoupledIOsbd

Destructive single bit IO access instructions

==== tio.bseti.y

Synopsis::
Destructive single bit set (immediate)

Mnemonic::
```
tio.bseti{bsel}.y iod, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x7 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 4, name: 0x0 },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x7 },
 { bits: 5, name: 'sideOP' },
 { bits: 6, name: 'shamt' },
 { bits: 4, name: 0x0 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.bclri.y

Synopsis::
Destructive single bit clear (immediate)

Mnemonic::
```
tio.bclri{bsel}.y iod, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x7 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 4, name: 0x1 },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x7 },
 { bits: 5, name: 'sideOP' },
 { bits: 6, name: 'shamt' },
 { bits: 4, name: 0x1 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.binvi.y

Synopsis::
Destructive single bit invert (immediate)

Mnemonic::
```
tio.binvi{bsel}.y iod, shamt
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x7 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'shamt' },
 { bits: 1, name: 0 },
 { bits: 4, name: 0x2 },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x7 },
 { bits: 5, name: 'sideOP' },
 { bits: 6, name: 'shamt' },
 { bits: 4, name: 0x2 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.bset.y

Synopsis::
Destructive single bit set

Mnemonic::
```
tio.bset{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x6 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 4, name: 0x0 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.bclr.y

Synopsis::
Destructive single bit clear

Mnemonic::
```
tio.bclr{bsel}.y iod, rs2
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x6 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 4, name: 0x1 },
 { bits: 2, name: 'bsel' },
]}
....

==== tio.binv.y

Synopsis::
Destructive single bit invert

Mnemonic::
```
tio.binv{bsel}.y iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x2b, attr: ['CUSTOM-1'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x6 },
 { bits: 5, name: 'sideOP' },
 { bits: 5, name: 'rs2' },
 { bits: 1, name: 0 },
 { bits: 4, name: 0x2 },
 { bits: 2, name: 'bsel' },
]}
....

=== XTightlyCoupledIObf

IO bitfield instructions

==== tio.bfinserti.yx

Synopsis::
Destructive bitfield insert into IO register (immediate)

Mnemonic::
```
tio.bfinserti{bsel}.yx iod, rs1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x4 },
 { bits: 5, name: 'rs1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x4 },
 { bits: 5, name: 'rs1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: rv64 encoding could tradeoff the extra len/offset range similarly to branches

==== tio.bfinserti.yi

Synopsis::
Destructive bitfield insert into IO register from immediate (immediate)

Mnemonic::
```
tio.bfinserti{bsel}.yi iod, uimm, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'uimm[4:0]' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'iod' },
 { bits: 3, name: 0x5 },
 { bits: 5, name: 'uimm[4:0]' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

Description::
Insert `len` bits of expanded 'uimm[4:0]' constant into iod register at `offset` position.
The `uimm=0` is mapped into `-1` constant.

NOTE: due to encoding constraints only destructive form is provided

==== tio.bfextracti.xy

Synopsis::
extract bitfield from IO register (immediate)

Mnemonic::
```
tio.bfextracti{bsel}.xy rd, ios1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x6 },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x6 },
 { bits: 5, name: 'ios1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: instruction is equivalent to `tio.slli` + `srli` sequence

==== tio.sbfextracti.xy

Synopsis::
extract and sign extend bitfield from IO register (immediate)

Mnemonic::
```
tio.sbfextracti{bsel}.xy rd, ios1, offset, len
```

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x7 },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'offset' },
 { bits: 5, name: 'len' },
 { bits: 2, name: 'bsel' },
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x5b, attr: ['CUSTOM-2'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 0x7 },
 { bits: 5, name: 'ios1' },
 { bits: 6, name: 'offset' },
 { bits: 6, name: 'len' },
]}
....

NOTE: instruction is equivalent to `tio.slli` + `srai` sequence

=== XTightlyCoupledIOsbbr

branch on single IO bit instructions

==== tio.bsbseti.y

Synopsis::
Branch if single bit in IO register is set (immediate)

Mnemonic::
```
tio.bsbseti{bsel}.y ios1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x7b, attr: ['CUSTOM-3'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 2, name: 0x0 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

NOTE: only bottom 32 bits of target register are accessible on rv64

==== tio.bsbclri.y

Synopsis::
Branch if single bit in IO register is cleared (immediate)

Mnemonic::
```
tio.bsbclri{bsel}.y ios1, shamt, label
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x7b, attr: ['CUSTOM-3'] },
 { bits: 5, name: 'imm[4:1|11]' },
 { bits: 2, name: 0x1 },
 { bits: 1, name: 'bsel' },
 { bits: 5, name: 'ios1' },
 { bits: 5, name: 'shamt' },
 { bits: 7, name: 'imm[12|10:5]' },
]}
....

NOTE: only bottom 32 bits of target register are accessible on rv64

=== XTightlyCoupledIOfcvt

implemented similarly to F or Zfinx fcvt instructions

NOTE: ADC readings are often immediately converted to float for processing in control loop algorithms

==== tio.fcvt.s.w.sy

Synopsis::
Read IO register and convert to float

Mnemonic::
```
tio.fcvt{bsel}.s.w.sy rd, ios1, rm
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x53, attr: ['OP-FP'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 'rm' },
 { bits: 5, name: 'ios1' },
 { bits: 3, name: 0x4 },
 { bits: 2, name: 'bsel' },
 { bits: 2, name: 'fmt', attr: ['S'] },
 { bits: 5, name: 0x1a },
]}
....

Prerequisites::
F or Zfinx

==== tio.fcvt.s.wu.sy

Synopsis::
Read IO register and convert to float

Mnemonic::
```
tio.fcvt{bsel}.s.wu.sy rd, ios1, rm
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits: 7, name: 0x53, attr: ['OP-FP'] },
 { bits: 5, name: 'rd' },
 { bits: 3, name: 'rm' },
 { bits: 5, name: 'ios1' },
 { bits: 3, name: 0x5 },
 { bits: 2, name: 'bsel' },
 { bits: 2, name: 'fmt', attr: ['S'] },
 { bits: 5, name: 0x1a },
]}
....

Prerequisites::
F or Zfinx

==== TODO: double precision and rv64

==== TODO: float to int

potentially problematic to implement, as the float pipe 
is usually longer than integer one

=== XTightlyCoupledIOcm

implemented similarly to Zcm* extensions, incompatible with Zcd

==== tio.cm.mv.yx

Synopsis::
Move into IO register

Mnemonic::
```
tio.cm.mv{bsel}.yx iod, rs2
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits:  2, name: 0x0, attr: ['C0'] },
 { bits:  5, name: 'rs2' },
 { bits:  5, name: 'iod' },
 { bits:  1, name: 'bsel' },
 { bits:  3, name: 0x5, attr: ['FSD'] },
],config:{bits:16}}
....

Prerequisites::
Zca

==== tio.cm.mv.xy

Synopsis::
Move from IO register

Mnemonic::
```
tio.cm.mv{bsel}.xy rd, ios1
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits:  2, name: 0x2, attr: ['C2'] },
 { bits:  5, name: 'ios1' },
 { bits:  5, name: 'rd' },
 { bits:  1, name: 'bsel' },
 { bits:  3, name: 0x1, attr: ['FLDSP'] },
],config:{bits:16}}
....

Prerequisites::
Zca

NOTE: ios1 in rs2 position, the low bits store only rd' in C extension, maybe swap?

==== tio.cm.bseti0.y

Synopsis::
Set bit in IO register (immediate)

Mnemonic::
```
tio.cm.bseti0.y iod, shamt
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits:  2, name: 0x0, attr: ['C0'] },
 { bits:  5, name: 'shamt' },
 { bits:  5, name: 'iod' },
 { bits:  1, name: '0' },
 { bits:  3, name: 0x1, attr: ['FLD'] },
],config:{bits:16}}
....

Prerequisites::
Zca

NOTE: only bottom 32 bits are accessible on rv64

==== tio.cm.bclri0.y

Synopsis::
Clear bit in IO register (immediate)

Mnemonic::
```
tio.cm.bclri0.y iod, shamt
```

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
 { bits:  2, name: 0x0, attr: ['C0'] },
 { bits:  5, name: 'shamt' },
 { bits:  5, name: 'iod' },
 { bits:  1, name: '1' },
 { bits:  3, name: 0x1, attr: ['FLD'] },
],config:{bits:16}}
....

Prerequisites::
Zca

NOTE: only bottom 32 bits are accessible on rv64

=== XTightlyCoupledIOsideOPdelay

This extension provides optional 0 to 31 cycles of delay before the next IO targetting instruction
can be executed. Number of delay cycles is encoded as `uimm[4:0]` in sideOP position.

It starts in next cycle after the implied writeback stage (and write side effects)
The delayed instruction cannot trigger any of the side effects until
the implied downcounter of delay reaches zero at the cycle of instructions
implied writeback stage (and write side effects).

NOTE: allowing execution of regular instructions under delay window allows to achieve
deterministic timing under non-deterministic execution conditions (caches, flash waitstates etc.),
where extra computation is necessary (bit stuffing, access fifos etc.)

NOTE: other sideOP behaviour can be configured by a custom CSR of another extension

example of generating 50:50 square wave with 64 cycle period::
[source, asm]
```
1:
	tio.bseti GPIOA_ODR, 17, [31]
	tio.bclri GPIOA_ODR, 17, [31]
	b 1b
```

//should be in appendix?

==== TODO: delay vs interrupts

Interrupted context with delay shouldn't affect execution of IO instructions inside the interrupt handlers.
It also shouldn't freeze for the duration of the ISR as well as it shouldn't be "removed" 
by interrupts shorter than remaining delay.

[appendix]
== code samples

risc-v listings were generated by "clang 15.0.0" with `-Os -march=rv32gc_zba_zbb_zbs` flags. (clang as the listing is cleaner
than in gcc, and the generated code is a bit more efficient)

armv7m listings were generated by "gcc 11.2.1 (none)" with `-Os -mcpu=cortex-m4` flags. (newest non linux one on godbolt)

=== stm32 GPIO output toggle

[source, C]
```
void toggle() {
    GPIOB->ODR ^= GPIO_ODR_13;
}
```

NOTE: on avr8 GPIO pin toggling can be achieved by writing into PINxn registers by `out` or `sbi` instructions
(the `sbi` here is not a RMW)

risc-v::
[source, asm]
```
toggle():                             # @toggle()
        lui     a0, 294912
        lw      a1, 1044(a0)
        binvi   a1, a1, 13
        sw      a1, 1044(a0)
        ret
```

armv7m::
[source, asm]
```
toggle():
        ldr     r2, .L5
        ldr     r3, [r2, #20]
        eor     r3, r3, #8192
        str     r3, [r2, #20]
        bx      lr
.L5:
        .word   1207960576
```

risc-v + XTightlyCoupledIO::
[source, asm]
```
toggle():
	tio.binvi GPIOB_ODR, 13
	ret
```

=== stm32f0 minimum PLL clock init (assume reset state of registers, no other config)

[source, C]
```
void init_clocks()
{
	FLASH->ACR = FLASH_ACR_PRFTBE | (FLASH_ACR_LATENCY_Msk & 0b001); // 1ws

	RCC->CFGR = RCC_CFGR_PLLMUL12;

	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));

	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}
```

risc-v::
[source, asm]
```
init_clocks():                       # @init_clocks()
        lui     a0, 262178
        li      a1, 17
        sw      a1, 0(a0)
        lui     a0, 262177
        lui     a1, 640
        sw      a1, 4(a0)
        lw      a1, 0(a0)
        bseti   a1, a1, 24
        sw      a1, 0(a0)
.LBB0_1:                                # =>This Inner Loop Header: Depth=1
        lw      a1, 0(a0)
        slli    a1, a1, 6
        bgez    a1, .LBB0_1
        lui     a0, 262177
        lw      a1, 4(a0)
        ori     a1, a1, 2
        sw      a1, 4(a0)
        li      a1, 8
.LBB0_3:                                # =>This Inner Loop Header: Depth=1
        lw      a2, 4(a0)
        andi    a2, a2, 12
        bne     a2, a1, .LBB0_3
        ret
```

NOTE: gcc 12.2 fails to detect `slli` + `bgez` pattern and performs 
li + and + beq, even though on arm it works fine

armv7m::
[source, asm]
```
init_clocks():
        ldr     r3, .L7
        movs    r2, #17
        str     r2, [r3]
        sub     r3, r3, #4096
        mov     r2, #2621440
        str     r2, [r3, #4]
        ldr     r2, [r3]
        orr     r2, r2, #16777216
        str     r2, [r3]
.L2:
        ldr     r2, [r3]
        lsls    r2, r2, #6
        bpl     .L2
        ldr     r2, [r3, #4]
        orr     r2, r2, #2
        str     r2, [r3, #4]
.L3:
        ldr     r2, [r3, #4]
        and     r2, r2, #12
        cmp     r2, #8
        bne     .L3
        bx      lr
.L7:
        .word   1073881088
```

risc-v + XTightlyCoupledIO::
[source, asm]
```
init_clocks():
	tio.addi FLASH_ACR, zero, (FLASH_ACR_PRFTBE | (FLASH_ACR_LATENCY_Msk & 0b001))
	lui t0, %hi(RCC_CFGR_PLLMUL12)
	tio.cm.mv RCC_CFGR, t0 // no need for addi
	tio.cm.bseti RCC_CR, RCC_CR_PLLON_Pos
1:
	tio.bsbclri RCC_CR1, RCC_CR_PLLRDY_Pos, 1b
	tio.cm.bseti RCC_CFGR, RCC_CFGR_SW_Pos+1 // effectively 0b10
2:
	tio.bfextracti t0, RCC_CFGR, RCC_CFGR_SWS_Pos, 2
	tio.bnei t0, (RCC_CFGR_SWS_PLL >> RCC_CFGR_SWS_Pos), 2b
	ret
```

=== stm32f0 minimum PLL clock init (assume unknown or "worst case" state of registers)

[source, C]
```
void init_clocks2()
{
	FLASH->ACR = FLASH_ACR_PRFTBE | (FLASH_ACR_LATENCY_Msk & 0b001); // 1ws

	if((RCC->CFGR & RCC_CFGR_SWS) == RCC_CFGR_SWS_PLL)
	{
		RCC->CFGR &= ~RCC_CFGR_SW_Msk; // switch to HSI (0b00)
		while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI);
	}

	RCC->CR &= ~RCC_CR_PLLON;
	while((RCC->CR & RCC_CR_PLLRDY))

	RCC->CFGR = RCC_CFGR_PLLMUL12 | (RCC->CFGR & ~RCC_CFGR_PLLMUL_Msk); 
	
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));

	RCC->CFGR = RCC_CFGR_SW_PLL | (RCC->CFGR & ~RCC_CFGR_SW_Msk);
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}
```

risc-v::
[source, asm]
```
init_clocks2():                      # @init_clocks2()
        lui     a0, 262178
        li      a1, 17
        sw      a1, 0(a0)
        lui     a0, 262177
        lw      a1, 4(a0)
        andi    a1, a1, 12
        li      a2, 8
        bne     a1, a2, .LBB1_3
        lw      a1, 4(a0)
        andi    a1, a1, -4
        sw      a1, 4(a0)
.LBB1_2:                                # =>This Inner Loop Header: Depth=1
        lw      a1, 4(a0)
        andi    a1, a1, 12
        bnez    a1, .LBB1_2
.LBB1_3:
        lw      a1, 0(a0)
        bclri   a1, a1, 24
        sw      a1, 0(a0)
.LBB1_4:                                # =>This Inner Loop Header: Depth=1
        lw      a1, 0(a0)
        slli    a1, a1, 6
        bltz    a1, .LBB1_4
        lui     a0, 262177
        lw      a1, 4(a0)
        lui     a2, 1047616
        addi    a2, a2, -1
        and     a1, a1, a2
        bseti   a1, a1, 19
        bseti   a1, a1, 21
        sw      a1, 4(a0)
        lw      a1, 0(a0)
        bseti   a1, a1, 24
        sw      a1, 0(a0)
.LBB1_6:                                # =>This Inner Loop Header: Depth=1
        lw      a1, 0(a0)
        slli    a1, a1, 6
        bgez    a1, .LBB1_6
        lui     a0, 262177
        lw      a1, 4(a0)
        andi    a1, a1, -4
        ori     a1, a1, 2
        sw      a1, 4(a0)
        li      a1, 8
.LBB1_8:                                # =>This Inner Loop Header: Depth=1
        lw      a2, 4(a0)
        andi    a2, a2, 12
        bne     a2, a1, .LBB1_8
        ret
```

armv7m::
[source, asm]
```
init_clocks2():
        ldr     r3, .L20
        movs    r2, #17
        str     r2, [r3]
        sub     r3, r3, #4096
        ldr     r2, [r3, #4]
        and     r2, r2, #12
        cmp     r2, #8
        bne     .L10
        ldr     r2, [r3, #4]
        bic     r2, r2, #3
        str     r2, [r3, #4]
.L11:
        ldr     r2, [r3, #4]
        tst     r2, #12
        bne     .L11
.L10:
        ldr     r2, [r3]
        bic     r2, r2, #16777216
        str     r2, [r3]
.L12:
        ldr     r2, [r3]
        lsls    r1, r2, #6
        bmi     .L12
        ldr     r2, [r3, #4]
        bic     r2, r2, #3932160
        orr     r2, r2, #2621440
        str     r2, [r3, #4]
        ldr     r2, [r3]
        orr     r2, r2, #16777216
        str     r2, [r3]
.L13:
        ldr     r2, [r3]
        lsls    r2, r2, #6
        bpl     .L13
        ldr     r2, [r3, #4]
        bic     r2, r2, #3
        orr     r2, r2, #2
        str     r2, [r3, #4]
.L14:
        ldr     r2, [r3, #4]
        and     r2, r2, #12
        cmp     r2, #8
        bne     .L14
        bx      lr
.L20:
        .word   1073881088
```

NOTE: gcc fails to detect `bfi` from constant, pattern generally

risc-v + XTightlyCoupledIO::
[source, asm]
```
init_clocks2():
	tio.addi FLASH_ACR, zero, (FLASH_ACR_PRFTBE | (FLASH_ACR_LATENCY_Msk & 0b001))
	tio.bfextracti a0, RCC_CFGR, RCC_CFGR_SWS_Pos, 2
	tio.bnei a0, (RCC_CFGR_SWS_PLL >> RCC_CFGR_SWS_Pos), 2f
	tio.bfinserti RCC_CFGR, zero, RCC_CFGR_SW_Pos, 2
1:
	tio.bfextracti a0, RCC_CFGR, RCC_CFGR_SWS_Pos, 2
	c.bnez a0, 1b // needs x8-x15 register
2:
	tio.cm.bclri RCC_CR, RCC_CR_PLLON_Pos
3:
	tio.bsbseti RCC_CR, RCC_CR_PLLRDY_Pos, 3b
	tio.bfinserti RCC_CFGR, (RCC_CFGR_PLLMUL12 >> RCC_CFGR_PLLMUL_Pos), RCC_CFGR_PLLMUL_Pos, 4
	tio.cm.bseti RCC_CR, RCC_CR_PLLON_Pos
4:
	tio.bsbclri, RCC_CR, RCC_CR_PLLRDY_Pos, 4b
	tio.bfinserti RCC_CFGR, (RCC_CFGR_SW_PLL >> RCC_CFGR_SW_Pos), RCC_CFGR_SW_Pos, 2
5:
	tio.bfextracti a0, RCC_CFGR, RCC_CFGR_SWS_Pos, 2
	tio.bnei a0, (RCC_CFGR_SWS_PLL >> RCC_CFGR_SWS_Pos), 5b
	ret
```

=== stm32f0 gpio + timer init for 7 segment display (assume reset state of registers)

comes from: https://github.com/jnk0le/random/tree/master/stm32_7segment

[source, C]
```
void init_7seg() {
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN | RCC_AHBENR_GPIOFEN;
	
	//common
	GPIOB->MODER |= (0b01 << GPIO_MODER_MODER1_Pos);
	GPIOF->MODER |= (0b01 << GPIO_MODER_MODER0_Pos) | (0b01 << GPIO_MODER_MODER1_Pos);
	GPIOA->MODER |= (0b01 << GPIO_MODER_MODER9_Pos);

	//initialize to disabled state (common scattered will blink first digit on all columns on startup otherwise)
	GPIOB->BSRR = GPIO_BSRR_BS_1;
	GPIOF->BSRR = GPIO_BSRR_BS_0 | GPIO_BSRR_BS_1;
	GPIOA->BSRR = GPIO_BSRR_BS_9;

	//segment
	GPIOA->MODER |= (0b01 << GPIO_MODER_MODER4_Pos)
		|(0b01 << GPIO_MODER_MODER2_Pos)
		|(0b01 << GPIO_MODER_MODER6_Pos)
		|(0b01 << GPIO_MODER_MODER5_Pos)
		|(0b01 << GPIO_MODER_MODER1_Pos)
		|(0b01 << GPIO_MODER_MODER3_Pos)
	    |(0b01 << GPIO_MODER_MODER7_Pos)
		|(0b01 << GPIO_MODER_MODER0_Pos);

	GPIOA->OSPEEDR |= (0b11 << GPIO_OSPEEDR_OSPEEDR4_Pos)
		|(0b11 << GPIO_OSPEEDR_OSPEEDR2_Pos)
		|(0b11 << GPIO_OSPEEDR_OSPEEDR6_Pos)
		|(0b11 << GPIO_OSPEEDR_OSPEEDR5_Pos)
		|(0b11 << GPIO_OSPEEDR_OSPEEDR1_Pos)
		|(0b11 << GPIO_OSPEEDR_OSPEEDR3_Pos)
		|(0b11 << GPIO_OSPEEDR_OSPEEDR7_Pos)
		|(0b11 << GPIO_OSPEEDR_OSPEEDR0_Pos);

	RCC->APB2ENR |= RCC_APB2ENR_TIM16EN;

	TIM16->DIER = TIM_DIER_UIE;

	TIM16->ARR = 47999; // 1khz isr rate at 48 mhz

	TIM16->CR1 = TIM_CR1_CEN;

	//NVIC_EnableIRQ(TIM16_IRQn);
}
```

risc-v::
[source, asm]
```
init_7seg():                    # @init_7seg_gpio()
        lui     a0, 262177
        lw      a1, 20(a0)
        lui     a2, 1120
        or      a1, a1, a2
        sw      a1, 20(a0)
        lui     a1, 294912
        lw      a2, 1024(a1)
        ori     a2, a2, 4
        sw      a2, 1024(a1)
        lui     a2, 294913
        lw      a3, 1024(a2)
        ori     a3, a3, 5
        sw      a3, 1024(a2)
        lw      a3, 0(a1)
        bseti   a3, a3, 18
        sw      a3, 0(a1)
        li      a3, 2
        sw      a3, 1048(a1)
        li      a3, 3
        sw      a3, 1048(a2)
        li      a2, 512
        sw      a2, 24(a1)
        lw      a2, 0(a1)
        lui     a3, 5
        addi    a3, a3, 1365
        or      a2, a2, a3
        sw      a2, 0(a1)
        lw      a2, 8(a1)
        lui     a3, 16
        addi    a3, a3, -1
        or      a2, a2, a3
        sw      a2, 8(a1)
        lw      a1, 24(a0)
        bseti   a1, a1, 17
        sw      a1, 24(a0)
        lui     a0, 262164
        li      a1, 1
        sw      a1, 1036(a0)
        lui     a2, 12
        addi    a2, a2, -1153
        sw      a2, 1068(a0)
        sw      a1, 1024(a0)
        ret
```

armv7m::
[source, asm]
```
init_7seg():
        ldr     r1, .L2
        ldr     r0, .L2+4
        ldr     r3, [r1, #20]
        ldr     r2, .L2+8
        orr     r3, r3, #4587520
        push    {r4, lr}
        str     r3, [r1, #20]
        ldr     r3, [r0]
        orr     r3, r3, #4
        str     r3, [r0]
        ldr     r3, [r2]
        orr     r3, r3, #5
        str     r3, [r2]
        mov     r3, #1207959552
        ldr     r4, [r3]
        orr     r4, r4, #262144
        str     r4, [r3]
        movs    r4, #2
        str     r4, [r0, #24]
        movs    r0, #3
        str     r0, [r2, #24]
        mov     r2, #512
        str     r2, [r3, #24]
        ldr     r2, [r3]
        orr     r2, r2, #21760
        orr     r2, r2, #85
        str     r2, [r3]
        ldr     r2, [r3, #8]
        mvn     r2, r2, lsr #16
        mvn     r2, r2, lsl #16
        str     r2, [r3, #8]
        ldr     r3, [r1, #24]
        orr     r3, r3, #131072
        str     r3, [r1, #24]
        ldr     r3, .L2+12
        movs    r2, #1
        movw    r1, #47999
        str     r2, [r3, #12]
        str     r1, [r3, #44]
        str     r2, [r3]
        pop     {r4, pc}
.L2:
        .word   1073876992
        .word   1207960576
        .word   1207964672
        .word   1073824768
```

risc-v + XTightlyCoupledIO::
[source, asm]
```
init_7seg():
	lui t0, %hi(RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN | RCC_AHBENR_GPIOFEN)
	tio.or RCC_AHBENR, t0
	tio.cm.bseti GPIOB_MODER, GPIO_MODER_MODER1_Pos // '0' bit doesn't matter in oring
	c.li t0, (0b01 << GPIO_MODER_MODER0_Pos) | (0b01 << GPIO_MODER_MODER1_Pos)
	tio.or GPIOF_MODER, t0
	tio.cm.bseti GPIOA_MODER, GPIO_MODER_MODER9_Pos // '0' bit doesn't matter in oring
	tio.addi GPIOB_BSRR, zero, GPIO_BSRR_BS_1 // can also bseti from x0
	tio.addi GPIOF_BSRR, zero, (GPIO_BSRR_BS_0 | GPIO_BSRR_BS_1)
	tio.addi GPIOA_BSRR, zero, GPIO_BSRR_BS_9 // can also bseti from x0
	c.lui t0, %hi(0b01010101010101)
	addi t0, %lo(0b01010101010101)
	tio.or GPIOA_MODER, t0
	tio.bfinserti GPIOA_OSPEEDR, -1, 0, 16 // equiv to or
	tio.cm.bseti RCC_APB2ENR, RCC_APB2ENR_TIM16EN_Pos
	//c.li t1, 1 // UIE and CEN, 2 bytes smaller at higher reg presure
	//tio.cm.mv TIM16_DIER, t1
	tio.addi TIM16_DIER, zero, TIM_DIER_UIE // can also bseti from x0
	c.lui t0, %hi(47999)
	tio.addi TIM16_ARR, t0, %lo(47999)
	//tio.cm.mv TIM16_CR1, t1
	tio.addi TIM16_CR1, zero, TIM_CR1_CEN // can also bseti from x0
	ret
```

[bibliography]
== Bibliography

* [[[doc1292, 1]]] https://web.archive.org/web/20111213030633/http://www.atmel.com/dyn/resources/prod_documents/DOC1292.PDF
* [[[spracw5a, 2]]] https://www.ti.com/lit/an/spracw5a/spracw5a.pdf
